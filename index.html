<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Shake // Modern C++ Features</title>

    <link rel="stylesheet" href="revealjs/css/reveal.css">
    <link rel="stylesheet" href="revealjs/css/theme/white.css">
    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="revealjs/lib/css/zenburn.css">
    <link rel="stylesheet" href="mod/mod4revealjs.css">
    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'revealjs/css/print/pdf.css' : 'revealjs/css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>

<body>
    <div class="reveal">
        <div class="slides">
            <section>
                <h2>Modern C++ Features</h2>
                <h3>Past / Present / Future</h3>
            </section>
<!--
                   CCCCCCCCCCC                                 111          111    
                 CCCCCCCCCCCCCC                              11111        11111    
                CCCCC       CCC                            1111111      1111111    
                CCCC                +++          +++      11  1111     11  1111    
                CCCC                +++          +++          1111         1111    
                CCCC            +++++++++++  +++++++++++      1111         1111    
                CCCC            +++++++++++  +++++++++++      1111         1111    
                CCCCC       CCC     +++          +++          1111         1111    
                 CCCCCCCCCCCCCC     +++          +++          1111         1111    
                   CCCCCCCCCCC                            111111111111 111111111111
-->
            <section>
                <section id="cpp11">
                    <h1>C++ 11</h1>
                    <nav data-auto="usability='core language usability', functionality='core language functionality', stl='standard library', rtperf='core language runtime performance', misc='miscellaneous'"/>
                </section>

                <section>
                    <h2 data-category=functionality>#(keyword:alignas)# and #(keyword:alignof)#</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon whenneeded"></div>
                    <aside class="notes">
                        <ul>
                            <li>Current usage: not used a lot</li>
                            <li>Current directive: almost never recommended</li>
                            <li>Future directive: To use as soon as necessary</li>
                        </ul>
                    </aside>
                    <article>
                        <p>
                            C++11 allows variable alignment to be queried and controlled with #(keyword:alignof)# and #(keyword:alignas)#.
                        </p>
                        <p style="display: none;">
                            The #(keyword:alignof)# operator takes the type and returns the power of 2 byte boundary on which the type instances must be allocated (as a #(type:std::size_t)#).
                        </p>
                        <p style="display: none;">
                            When given a reference type alignof returns the referenced type's alignment; for arrays it returns the element type's alignment.
                        </p>
                        <p>
                            The #(keyword:alignas)# specifier controls the memory alignment for a variable. The specifier takes a constant or a type; when supplied a type #(code:alignas(T))# is shorthand for #(code:alignas(alignof(T)))#.
                        </p>
                        <!-- <p>
                            For example, to specify that a char array should be properly aligned to hold a float:
                            <cppblock>
                                alignas(float) unsigned char c[sizeof(float)];
                            </cppblock>
                        </p> -->
                    </article>
                </section>

                <section>
                    <h2 data-category=stl>atomic operations</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon whenneeded"></div>
                    <article>
                        <p>
                            C++11 introduces the atomic operations library<br>needed for lock-free concurential programmation.
                        </p>
                        <p>
                            Every atomic operation is not splittable by any<br>other atomic operation involving the same object.
                        </p>
                        <p>
                            Atomic objects are "data races"-free.
                        </p>
                        <p>
                            The atomic operations are defined in the header file #(header:atomic)#.
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category=usability>#(keyword:auto)#</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon recommended"></div>
                    <article>
                        <p>
                            C++11 allows type inference.
                        </p>
                        <p>
                            The definition of a variable with an explicit initialization can use the #(keyword:auto)# keyword.<br>
                        </p>
                        <p>
                            This creates a variable of the specific type of the initializer:
                            <cppblock>
                                auto some_strange_callable_type = std::bind(&amp;some_function, _2, _1, some_object);
                                auto other_variable = 5;
                            </cppblock>
                        </p>
                        <p>
                            Almost always #(keyword:auto)#?
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category=usability>#(keyword:decltype)#</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon whenneeded"></div>
                    <article>
                        <p>
                            The keyword #(keyword:decltype)# can be used to determine the type of expression at compile-time.
                            <cppblock>
                                unsigned int some_int;
                                decltype(some_int) other_integer_variable = 5;
                            </cppblock>
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category="rtperf">#(keyword:constexpr)#</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon recommended"></div>
                    <article>
                        <p>
                            C++11 introduced the keyword #(keyword:constexpr)#.
                        </p>
                        <p>
                            The user can express that a function is a compile-time constant.
                        </p>
                        <p>
                            There are some limitations.
                        </p>
                        <p>
                            If it is called with not constant expression arguments, the call behaves as if the function were not constexpr.
                            <cppblock>
                                constexpr int siz() { return 42; }
                                int array[siz() + 17]; // illformed if siz() is not constexpr
                                template&lt;int I&gt; struct Bar {};
                                Bar&lt;siz()&gt; bar;  // illformed if siz() is not constexpr
                            </cppblock>
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category=functionality>Defaulted &amp; deleted functions</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon mandatory"></div>
                    <article>
                        <p>
                            C++11 allows the explicit defaulting and deleting of special member functions.
                            <cppblock>
                                struct Foo
                                {
                                    Foo() = default; // explicit instantiantion of default constructor
                                    Foo(int _value);
                                };
                                struct NonCopyable
                                {
                                    NonCopyable() = default;
                                    NonCopyable(const NonCopyable&amp;) = delete;
                                    NonCopyable&amp; operator=(const NonCopyable&amp;) = delete;
                                };
                            </cppblock>
                        </p>
                    </article>
                </section>
                
                <section>
                    <h2 no-toc>Defaulted &amp; deleted functions</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon mandatory"></div>
                    <article>
                        <p>
                            The #(code:= delete)# specifier can be used to prohibit calling any function,
                            which can be used to disallow calling a member function with particular parameters
                            (and to guard against implicit cast).
                            <cppblock>
                                struct Foo {
                                  Foo(double) {}
                                  Foo(int) =delete;                     // &lt;== guard from conversion from int
                                };
                                struct Bar {
                                  Bar(double) {}
                                  template&lt;typename T&gt; Bar(T) =delete; // &lt;== guard from any conversion but double
                                };
                            </cppblock>
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category=usability>Delegating constructors</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon recommended"></div>
                    <article>
                        <p>
                            Constructors can call other peer constructors:
                            <cppblock>
                                struct Foo {
                                    Foo(int _value) : value_(_value) {}
                                    Foo() : Foo(42) {} // &lt;== this constructor calls the other one
                                    int value_;
                                };
                            </cppblock>
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category=usability>inheriting constructors</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon recommended"></div>
                    <article>
                        <p>
                            A class can inherit constructors from its base class:
                            <cppblock>
                                struct Parent {
                                    explicit Parent(int _value) : value_{_value} {}
                                    Parent() : value_(-1) {}
                                    Parent(int _value1, int _value2) : value_{_value1 + _value2} {}
                                private:
                                    int value_;
                                };
                                struct Child : Parent {
                                    using Parent::Parent; // &lt;== inheriting all constructors of Parent
                                };
                                Child child0, child1(14, 28), child2(17); // child values are respectively: -1 42 17
                            </cppblock>
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category=usability>#(keyword:nullptr)#</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon mandatory"></div>
                    <article>
                        <p>
                            #(keyword:nullptr)# serves as a distinguished null pointer constant.
                        </p>
                        <p>
                            It is of type #(type:std::nullptr_t)#, which is implicitly convertible and comparable to any pointer type or pointer-to-member type.
                        </p>
                        <p>
                            It is <b><u>not</u></b> implicitly convertible or comparable to integral types, except for #(type:bool)#.
                        </p>
                </article>
                </section>

                <section>
                    <h2 data-category=functionality>#(keyword:static_assert)#</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon recommended"></div>
                    <article>
                        <div>
                            C++11 introduces a new way to test assertions<br>at compile-time,using the new keyword #(keyword:static_assert)#.
                            <cppblock>
                                static_assert((MC_PI > 3.14) && (MC_PI < 3.15), "MC_PI is inaccurate!");
                            </cppblock>
                        </div>
                        <div>
                            <cppblock>
                                template&lt;typename T>
                                struct Check {
                                static_assert(sizeof(int) <= sizeof(T), "T is not big enough!");
                                };
                            </cppblock>
                        </div>
                        <div>
                            <cppblock>
                                template&lt;typename INTEGRAL>
                                INTEGRAL foo(INTEGRAL x, INTEGRAL y) {
                                static_assert(std::is_integral&lt;INTEGRAL>::value,
                                    "foo() parameter must be an integral type.");
                                }
                            </cppblock>
                        </div>
                    </article>
                </section>

                <section>
                    <h2 data-category=usability>Strongly-typed enumerations</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon recommended"></div>
                    <article>
                        <div>
                            <p>
                                C++11 provides strongly-typed enumerations:
                            </p>
                            <ul>
                                <li>it can not be used for/assigned to/compared with another enumeration.</li>
                                <li>it is not implicitly converted to #(type:int)#.</li>
                                <li>there is no risk of name collisions due to the need to use scope resolution operator to access values,</li>
                                <li>the underlying type can be overridden to a different integral type (#(type:int)# by default)</li>
                            </ul>
                        </div>
                    </article>
                </section>

                <section>
                    <h2 no-toc>Strongly-typed enumerations</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon recommended"></div>
                    <article>
                        <div>
                            In C+11, as long as the size of the enumeration is specified implicitly or explicitly, it can be forward-declared:
                            <cppblock style="font-size: 45%;">
                                enum Enum1;                  // Invalid in C++03 and C++11; the underlying type cannot be determined.
                                enum Enum2 : unsigned int;   // Valid in C++11, the underlying type is specified explicitly.
                                enum class Enum3;            // Valid in C++11, the underlying type is int.
                                enum class Enum4 : int;      // Valid in C++11.
                                enum Enum2 : unsigned short; // Invalid in C++11, Enum2 was formerly declared with other underlying type.
                            </cppblock>
                        </div>
                        <p>
                            The forward-declaration, the scope resolution operator, and the choice of the underlying type are available <strong>even for old-style enumerations</strong>.
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category=functionality>Template aliases</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon mandatory"></div>
                    <aside class="notes">
                        <summary data-category="Current usage">used => #(keyword:typedef)# is deprecated</summary>
                        <summary data-category="Current directive">recommended</summary>
                        <summary data-category="Future directive">recommended</summary>
                    </aside>
                    <article>
                        <div>
                            C++11 allows to create templated synonym for template type.
                            The template parameters of the synonym can be different of the template parameters of the original type.<br>
                            <cppblock>
                                template&lt;typename First, typename Second, int Third>
                                class SomeType;

                                template&lt;typename Second>
                                using TypedefName = SomeType&lt;OtherType, Second, 5>;
                            </cppblock>
                            The syntax is generalized to define any synonym type in a more intuitively readable manner.
                            <cppblock>
                                typedef void (*OldFunctionType)(double);  // <== old style. tricky to read 

                                using NewFunctionType = void (*)(double); // <== new style. more obvious
                            </cppblock>
                        </div>
                    </article>
                </section>

                <section>
                    <h2 no-toc>Template aliases</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon mandatory"></div>
                    <article>
                        <div>
                            #(keyword:typedef)# is deprecated!
                        </div>
                    </article>
                </section>

                <section>
                    <h2 data-category=functionality>variadic templates</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon whenneeded"></div>
                    <article>
                        In C++11, templates can take variable numbers of template parameters.<br>
                        This also allows the definition of type-safe variadic functions
                    </article>
                </section>

                <section>
                    <h2 data-category=functionality>extern templates</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon whenneeded"></div>
                    <article>
                        <p>
                            C++11 provides a syntax to tell the compiler <span style="text-decoration: underline; font-weight: bolder">not</span> to instantiate the template in this translation unit.
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category=functionality>Thread-local storage</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon whenneeded"></div>
                    <article>
                        <p>
                            C++11 introduces the keyword #(keyword:thread_local)#.<br>
                            Any object which could have static storage duration may be given thread-local duration instead.<br>
                        </p>
                        <p>
                            Each thread holds its own copy of such variables.<br>
                            Lifetime of each copies of these variables is bound to the thread holding them.
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category=usability>unrestricted unions</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon whenneeded"></div>
                    <article>
                        <p>
                            Some restrictions on what types can be members of a #(keyword:union)# are lifted.
                            Unions can now have member with non trivial special member functions but it must be <u>manually defined</u>.
                            <cppblock style="font-size:40%;">
                                #include &lt;new> // Needed for placement 'new'.
                                struct Point {
                                    Point() {}
                                    Point(int _x, int _y): x_(_x), y_(_y) {}
                                    int x_, y_;
                                };
                                union U {
                                    int z;
                                    double w;
                                    Point p;
                                    U() {} // Due to the Point member, a constructor definition is needed.
                                    U(const Point& pt) : p(pt) {} // Construct Point object using initializer list.
                                    U& operator=(const Point& pt) { new(&p) Point(pt); return *this; } // placement 'new'.
                                };
                            </cppblock>
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category=usability>non-static data member initializers</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon recommended"></div>
                    <aside class="notes">
                        <summary data-category="Current usage">rarely used</summary>
                        <summary data-category="Current directive">sometimes recommended</summary>
                        <summary data-category="Future directive">recommended</summary>
                    </aside>
                    <article>
                        <p>
                            The user can assign a default value to non-static data members.
                        </p>
                        <p>
                            Each constructor will initialize these members with the default value only if it does not override the initialization with its own.
                        </p>
                        <p>
                            <cppblock>
                                struct Foo {
                                    Foo() {}             // value_ initialized with 509
                                    explicit Foo(int _value)
                                     : value_(_value) {} // value_ initialized with given parameter
                                private:
                                    int value_ = 509;
                                };
                            </cppblock>
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category=usability>Range-for loop</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon recommended"></div>
                    <article>
                        <p>
                            C++11 extends the syntax of the #(keyword:for)# statement to allow for easy iteration over a range of elements.
                            <cppblock>
                                int my_array[5] = {1, 2, 3, 4, 5};
                                // double the value of each element in my_array:
                                for (int& x: my_array)
                                {
                                    x *= 2;
                                }
                            </cppblock>
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category=usability>lambda expressions</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon whenneeded"></div>
                    <article>
                        <p>
                            Lambda are anonymous functions defined as follows:
                            <cppblock>
                                [](int x, int y) -> int { return x + y; }
                            </cppblock>
                        </p>
                        <p>
                            The return type can be omitted.
                            <cppblock>
                                [](int x, int y) { return x + y; }
                            </cppblock>
                        </p>
                        <p>
                            A lambda can capture variables (by copy or by reference):
                            <cppblock>
                                [copy, &amp;ref](int x) { ref = x + copy; }
                            </cppblock>
                        </p>
                    </article>
                </section>

                <section>
                    <h2 no-toc>lambda expressions</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon whenneeded"></div>
                    <article>
                        <p>
                            The type of a lambda is unspecified.
                            <!-- User must use #(keyword:auto)#. -->
                            <!-- #(code:auto lambda = [](int x, int y) { return x + y; })# -->
                        </p>
                        <p style="--width: 80%">
                            A lamba which capture no variable can be converted into a function pointer:
                            <cppblock>
                                int f(int(*_callback)(int, int)) { return _callback( 17, 25 ); }
                                int r = f([](int x, int y){ return x + y; });
                            </cppblock>
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category=usability>#(keyword:override)#</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon mandatory"></div>
                    <article>
                        <p>
                            Prevent from bad virtual function overriding.
                        </p>
                        <p style="--width: 80%">
                            The compiler will check the base classes to see if there is a virtual function with this exact signature.
                            If there is not, the compiler will indicate an error.
                            <cppblock>
                            struct Base {
                              virtual void foo(float);
                            };
                            struct Derived : Base {
                              void foo(int) override; // error: doesn't override a base class method
                            };
                        </cppblock>
                    </p>
                    </article>
                </section>

                <section>
                    <h2 data-category=usability>#(keyword:final)#</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon whenneeded"></div>
                    <article>
                        <p style="--width: 80%;">
                            Prevent inheriting from classes or simply preventing overriding method in derived classes.
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category="rtperf">rvalue reference and move semantics</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon whenneeded"></div>
                    <article>
                        <p style="--width: 94%">
                            C++11 adds a new non-const reference type called an rvalue reference, identified by #(code:T&&)#.
                            This refers to temporaries that are permitted to be modified after they are initialized, for the purpose of allowing "move semantics".
                        </p>
                        <p style="--width: 90%">
                            For safety reasons, some restrictions are imposed. A named variable will never be considered to be an rvalue even if it is declared as such.
                            To get an rvalue, the function template #(code:std::move)# should be used.
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category=functionality>Raw string literals</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon whenneeded"></div>
                    <article style="font-size:90%">
                        <p>
                            C++11 provides a raw string literal:
                            <cppblock>
                                R"delimiter(The String Data \ Stuff " )delimiter"
                            </cppblock>
                        </p>
                        <p>
                            Everything between the #(code:"delimiter()# and the #(code:)delimiter")# is part of the string.<br>
                        </p>
                        <p >
                            The #(code:")# and #(code:\)# characters do not need to be escaped.
                        </p>
                        <p style="--width: 90%">
                            The string #(code:delimiter)#  can be any string up to 16 characters in length, including the empty string.
                            This string cannot contain spaces, control characters, #(code:()#, #(code:))#, or the #(code:\)# character.
                            Using non-empty delimiter string allows the user to have #(code:))# characters within raw string literals.
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category=functionality>User-defined literals</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon whenneeded"></div>
                    <article style="font-size: 90%">
                        <p>
                            The user can define new kinds of literal modifiers that will construct objects based on the string of characters that the literal modifies.
                            User can intervene while two distinct phases: raw and cooked.
                            <table>
                                <tr><th>C++ literal</th><th>raw literal</th><th>cooked literal</th></tr>
                                <tr><td>#(code:1234)#</td><td>#(code:'1')#, #(code:'2')#, #(code:'3')#, #(code:'4')#</td><td>integer 1234</td></tr>
                                <tr><td>#(code:0xA)#</td><td>#(code:'0')#, #(code:'x')#, #(code:'A')#</td><td>integer 10</td></tr>
                            </table>
                        </p>
                        <p>
                            All user-defined literals are suffixes; defining prefix literals is not possible.<br>
                            All user-defined literals must start with an underscore (#(code:_)#), others are reserved by the standard.
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category=usability>Explicit conversion operators</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon mandatory"></div>
                    <article>
                        <p>
                            The #(keyword:explicit)# keyword can be applied to conversion operators.
                        </p>
                        <p style="--width: 88%">
                            As with constructors, it prevents using those conversion functions in implicit conversions. However, language contexts that
                            specifically need a boolean value (the conditions of if-statements and loops, and operands to the logical operators)
                            count as explicit conversions and can thus use a #(type:bool)# conversion operator.
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category=functionality>#(keyword:noexcept)#</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon idontknow"></div>
                    <article>
                        <p style="--width: 80%">
                            Compile-time specification of non-exception-throwing functions is available with the #(keyword:noexcept)# keyword, which is useful for optimization.
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category=usability>Trailing function return types</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon abandonned"></div>
                    <article>
                        <p>
                            C++11 introduced trailing-return-type function declaration syntax so the return type can depend on function parameters:
                            <cppblock>
                                template&lt;typename Lhs, typename Rhs>
                                auto adding_func(const Lhs &lhs, const Rhs &rhs) -> decltype(lhs+rhs) {return lhs + rhs;}
                            </cppblock>
                        </p>
                        <p style="--width:66%">
                            This syntax can be used for classic function declarations and definitions.
                            <cppblock>
                                struct SomeStruct {
                                    auto func_name(int x, int y) -> int;
                                };
                                auto SomeStruct::func_name(int x, int y) -> int {
                                    return x + y;
                                }
                            </cppblock>
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category=functionality>Type #(type:long long int)#</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon whenneeded"></div>
                    <article>
                        <p style="--width: 72%">
                            C++11 adds a new integer type #(type:long long int)# to address the problem that type #(type:long int)# having size of 64 bits on some popular implementations and 32 bits on others.
                            The new type is guaranteed to be at least as large as a long int, and have no fewer than 64 bits.
                        </p>
                        </article>
                </section>

                <section>
                    <h2 data-category=usability>Uniform initialization</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon recommended"></div>
                    <article>
                        <div>
                            C++11 provides a syntax that allows for fully uniform type initialization that works on any object.
                            It expands on the initializer list syntax:
                            <div style="display:grid; grid-template-columns: 50% 50%">
                                <cppblock>
                                    struct BasicStruct {
                                        int x;
                                        double y;
                                    };
                                    BasicStruct var1{5, 3.2};

                                    struct AltStruct {
                                        AltStruct(int x, double y) : x{x}, y{y} {}
                                        int x;
                                        double y;
                                    };
                                    AltStruct var2{2, 4.3};
                                </cppblock>
                                <cppblock>
                                    struct IdString {
                                        std::string name;
                                        int identifier;
                                    };

                                    IdString get_string() {
                                        // Note the lack of explicit type.
                                        return {"foo", 42};
                                    }
                                </cppblock>
                            </p>
                        </div>
                    </article>
                </section>

                <section>
                    <h2>Variadic macros</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon ifnochoice"></div>
                    <article>
                        <div>
                            <cppblock>
                                #define FOO(...) fprintf(stderr, __VA_ARGS__)
                                #define BAR(...) puts(#__VA_ARGS__)
                                #define QUZ(check, ...) ((check)?puts(#check):printf(__VA_ARGS__))
                                FOO("a = %d\n", a);
                                BAR(First, second and third);
                                QUZ(x>z, "x is %d and y is %d", x, y);
                            </cppblock>
                            becomes after the preprocessor pass
                            <cppblock>
                                fprintf(stderr, "a = %d\n", a);
                                puts("First, second and third");
                                ((x>z)?puts("x>z"):printf("x is %d and y is %d", x, y))
                            </cppblock>
                        </div>
                    </article>
                </section>

                <section>
                    <h2 data-category=usability>Right angle bracket</h2>
                    <div class="ribbon cpp11"></div>
                    <article>
                        <div>
                            C++11 improves the specification of the parser so that multiple right angle brackets will be interpreted as closing the template argument list where it is reasonable.
                            This can be overridden by using parentheses around parameter expressions using the <q>></q>, <q>>=</q> or <q>>></q> binary operators:
                            <cppblock>
                                template&lt;bool Test> class SomeType;
                                std::vector&lt;SomeType&lt;1>2>> x1;   // Interpreted as a std::vector of SomeType&lt;true>,
                                    // followed by "2 >> x1", which is not valid syntax for a declarator.
                                std::vector&lt;SomeType&lt;(1>2)>> x1; // Interpreted as std::vector of SomeType&lt;false>,
                                    // followed by the declarator "x1", which is valid C++11 syntax.
                            </cppblock>
                        </div>
                    </article>
                </section>

                <section>
                    <h2 data-category=stl>STL</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon whenneeded"></div>
                    <article>
                        <div>
                            <ul>
                                <li>hashtables: #(type:std::unordered_set)#, #(type:std::unordered_map)#, ...</li>
                                <li>Type traits for meta-programming: #(type:std::enable_if)#, #(type:std::conditional)#, ...</li>
                                <li>#(code:std::begin)#, #(code:std::end)#</li>
                                <li>#(type:std::reference_wrapper)#</li>
                                <li>Extensible random number facility</li>
                                <li>Threading facilities</li>
                                <li>Polymorphic wrappers for function objects: #(type:std::function)#</li>
                            </ul>
                        </div>
                    </article>
                </section>

                <section>
                    <h2 data-category=stl>smart pointers</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon recommended"></div>
                    <article>
                        <div>
                        <p>C++11 provides #(type:std::shared_ptr)#, #(type:std::weak_ptr)#, #(type:std::unique_ptr)#</p>
                        <p>#(type:std::auto_ptr)# is deprecated.</p>
                        </div>
                    </article>
                </section>
    
                <section>
                    <h2 data-category=stl>Regular expressions</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon whenneeded"></div>
                    <article>
                        <div>
                            The new library, defined in the new header #(header:regex)#, is made of a couple of new classes:
                            <ul>
                                <li>regular expressions are represented by instance of the template class #(type:std::regex)#,</li>
                                <li>occurences are represented by instance of the template class #(type:std::match_results)#.</li>
                            </ul>
                            <p>
                                The function #(code:std::regex_search)# is used for searching, and #(code:std::regex_replace)# is used for replacing.
                            </p>
                        </div>
                    </article>
                </section>

                <section>
                    <h2 data-category=stl>#(type:std::tuple)#</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon whenneeded"></div>
                    <article>
                        <div>
                            Tuples are collections composed of heterogeneous objects of pre-arranged dimensions.
                            A tuple can be considered a generalization of a struct's member variables.
                            <cppblock>
                                typedef std::tuple&lt;int, double, long&, const char*> test_tuple;
                                long lengthy = 12;
                                test_tuple proof (18, 6.5, lengthy, "Ciao!");

                                lengthy = std::get<0>(proof);  // Assign to 'lengthy' the value 18.
                                std::get<3>(proof) = " Beautiful!";  // Modify the tuple’s fourth element.
                            </cppblock>
                        </div>
                    </article>
                </section>

                <section>
                    <h2 data-category=stl>initializer lists</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon whenneeded"></div>
                    <article>
                        <div>
                            C++11 extends initializer-lists, so they can be used for all classes (C++03 allow them only on structs and classes that conform to the POD definition.
                            C++11 binds the concept to a template, called #(code:std::initializer_list)#.
                            This allows constructors and other functions to take initializer-lists as parameters.
                            <cppblock>
                                struct SequenceClass
                                {
                                    SequenceClass(std::initializer_list&lt;int> list);
                                };
                            </cppblock>
                        </div>
                    </article>
                </section>

                <section>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon whenneeded"></div>
                    <h2 no-toc>initializer lists</h2>
                    <article>
                        <div>
                            This allows #(type:SequenceClass)# to be constructed from a sequence of integers, such as
                            <cppblock>
                                SequenceClass some_var = {1, 4, 5, 6};
                            </cppblock>
                            This constructor is a special kind of constructor, called an initializer-list-constructor.
                            Classes with such a constructor are treated specially during uniform initialization.
                            If a class has an initializer list constructor, then it takes priority over other forms of construction, provided that the initializer list conforms to the sequence constructor's type.
                        </div>
                    </article>
                </section>

                <section>
                    <div class="ribbon cpp11"></div>
                    <h2>misc</h2>
                    <article>
                        <p>
                            C++11 allows #(keyword:sizeof)# to work on members of classes without an explicit object.
                        </p>
                    </article>
                </section>
                <!--
                    ### Extended friend declarations
                    ### Local and unnamed types as template parameters
                    ### Inline namespaces
                    ### New character types
                    ### Unicode string literals
                    ### ref qualifier
                    ### dynamic initializaion and destruction with concurrency(magic statics)
                -->
            </section>
<!--
                   CCCCCCCCCCC                                 111            4444  
                 CCCCCCCCCCCCCC                              11111           44444  
                CCCCC       CCC                            1111111         4444444  
                CCCC                +++          +++      11  1111       4444 4444  
                CCCC                +++          +++          1111      4444  4444  
                CCCC            +++++++++++  +++++++++++      1111     4444444444444
                CCCC            +++++++++++  +++++++++++      1111     4444444444444
                CCCCC       CCC     +++          +++          1111            4444  
                 CCCCCCCCCCCCCC     +++          +++          1111            4444  
                   CCCCCCCCCCC                            111111111111        4444  
-->
            <section>
                <section>
                    <h1>C++ 14</h1>
                    <nav data-auto="language='new language feature', stl='new standard library feature', misc='miscellaneous'"/>
                </section>

                <!-- <section>
                    <h2 data-category="language">Tweaked wording for contextual conversions</h2>
                    <div class="ribbon cpp14"></div>
                    <div class="ribbon tobedefined"></div>
                    <article>
                        <div>
                            ???
                        </div>
                    </article>
                </section> -->

                <section>
                    <h2 data-category="language">Binary literals</h2>
                    <div class="ribbon cpp14"></div>
                    <div class="ribbon whenneeded"></div>
                    <article>
                        <div>
                            Numeric literals in C++14 can be specified in binary form.<br><br>
                            The syntax uses the prefixes #(code:0b)# or #(code:0B)#.
                        </div>
                    </article>
                </section>

                <section>
                    <h2 data-category="language" >Return type deduction for normal functions</h2>
                    <div class="ribbon cpp14"></div>
                    <div class="ribbon tobedefined"></div>
                    <!-- #(keyword:decltype(auto))#,  -->
                    <article>
                        <div style="font-size: 70%">
                            <p>
                                C++11 allowed lambda functions to deduce the return type based on the type of the expression given to the return statement.
                            </p>
                            <p>
                                C++14 provides this ability to all functions.
                            </p>
                            <p>
                                It also extends these facilities to lambda functions, allowing return type deduction for functions that are not of the form #(code:return expression;)#
                            </p>
                            <p>
                                To induce return type deduction, the function must be declared with #(keyword:auto)# as the return type, but without the trailing return type specifier.
                                <cppblock>
                                    auto DeduceReturnType();   // Return type to be determined.
                                </cppblock>
                            </p>
                            <p>
                                Recursion can be used with a function of this type, but the recursive call must happen after at least one return statement in the definition of the function.
                            </p>
                        </div>
                    </article>
                </section>

                <section>
                    <h2 no-toc>Return type deduction for normal functions (2/2)</h2>
                    <div class="ribbon cpp14"></div>
                    <div class="ribbon tobedefined"></div>
                    <article style="font-size: 65%; text-align: left;">
                        <div>
                            In C++11, two methods of type deduction were added:
                            <ul>
                                <li>
                                    #(keyword:auto)# was a way to create a variable of the appropriate type, based on a given expression.
                                </li>
                                <li>
                                    #(keyword:decltype)# was a way to compute the type of a given expression.
                                </li>
                            </ul>
                        </div>
                        <div>
                            However, decltype and auto deduce types in different ways:
                            <ul>
                                <li>
                                    #(code:auto)# always deduces a non-reference type, while #(code:auto&&)# always deduces a reference type.
                                </li>
                                <li>
                                    #(code:decltype)# can be prodded into deducing a reference or non-reference type, based on the value category of the expression and the nature of the expression it is deducing
                                </li>
                            </ul>
                            <cppblock>
                                int   i;
                                int&& f();
                                auto          x3a = i;     // decltype(x3a) is int
                                decltype(i)   x3d = i;     // decltype(x3d) is int
                                auto          x4a = (i);   // decltype(x4a) is int
                                decltype((i)) x4d = (i);   // decltype(x4d) is int&
                                auto          x5a = f();   // decltype(x5a) is int
                                decltype(f()) x5d = f();   // decltype(x5d) is int&&
                            </cppblock>
                            C++14 adds the #(code:decltype(auto))# syntax. This allows #(keyword:auto)# declarations to use the #(keyword:decltype)# rules on the given expression.
                        </div>
                        <div>

                        </div>
                    </article>

                </section>

                <section>
                    <h2 data-category="language">Initialized/Generalized lambda captures (init-capture)</h2>
                    <div class="ribbon cpp14"></div>
                    <div class="ribbon whenneeded"></div>
                    <article style="font-size: 75%;">
                        <div>
                            <p>
                                C++11 lambda functions capture variables declared in their outer scope by copy or by reference.<br>
                                This means that value members of a lambda cannot be move-only types.
                            </p>
                            <p>
                                C++14 allows captured members to be initialized with arbitrary expressions.<br>
                                This allows both capture by value-move and declaring arbitrary members of the lambda, without having a correspondingly named variable in an outer scope:
                            </p>
                            <cppblock>
                                auto lambda = [value = 1] {return value;};
                            </cppblock>
                            <p>
                                The lambda function lambda returns 1, which is what value was initialized with.
                            </p>
                            <p>
                                The declared capture deduces the type from the initializer expression as if by #(keyword:auto)#.<br>
                                This can be used to capture by move, via the use of the standard #(code:std::move)# function:
                            </p>
                            <cppblock>
                                std::unique_ptr&lt;int> ptr(new int(10));
                                auto lambda = [value = std::move(ptr)] {return *value;};
                            </cppblock>
                        </div>
                    </article>
                </section>

                <section>
                    <h2 data-category="language">Generic (polymorphic) lambda expressions</h2>
                    <div class="ribbon cpp14"></div>
                    <div class="ribbon tobedefined"></div>
                    <article style="font-size: 80%">
                        <div>
                            <p>
                                In C++11, lambda function parameters need to be declared with concrete types.<br>
                                C++14 relaxes this requirement, allowing lambda function parameters to be declared with the auto type specifier.
                            </p>
                            <cppblock>
                                auto lambda = [](auto x, auto y) {return x + y;};
                            </cppblock>
                            <p>
                                As for auto type deduction, generic lambdas follow the rules of template argument deduction (which are similar, but not identical in all respects).
                            </p>
                            <p>
                                The above code is equivalent to this:
                            </p>
                            <cppblock>
                                struct unnamed_lambda
                                {
                                    template&lt;typename T, typename U>
                                    auto operator()(T x, U y) const {return x + y;}
                                };
                                auto lambda = unnamed_lambda{};
                            </cppblock>
                        </div>
                    </article>
                </section>

                <section>
                    <h2 data-category="language">Variable templates</h2>
                    <div class="ribbon cpp14"></div>
                    <div class="ribbon whenneeded"></div>
                    <article style="font-size: 83%">
                        <p>
                            In prior versions of C++, only functions, classes or type aliases could be templated.
                        </p>
                        <p>
                            C++14 now allows the creation of variables that are templated.
                        </p>
                            <p>
                            The usual rules of templates apply to such declarations and definitions, including specialization.
                        </p>
                        <div>
                            <cppblock>
                                template&lt;typename T>
                                constexpr T pi = T(3.141592653589793238462643383);

                                // Usual specialization rules apply:
                                template&lt;>
                                constexpr const char* pi&lt;const char*> = "pi";
                            </cppblock>
                        </div>
                    </article>
                </section>

                <section>
                    <h2 data-category="language">Extended constexpr</h2>
                    <div class="ribbon cpp14"></div>
                    <div class="ribbon whenneeded"></div>
                    <article style="font-size:75%">
                        <div>
                            <p>
                                #(keyword:constexpr)#-declared functions may now contain the following:
                            </p>
                            <ul style="width:70%">
                                <li>
                                    any declarations except:
                                    <ul>
                                        <li>#(keyword:static)# or #(keyword:thread_local)# variables,</li>
                                        <li>variable declaration without initializers.</li>
                                    </ul>
                                </li>
                                <li>
                                    The conditional branching #(keyword:if)# and #(keyword:switch)#.
                                </li>
                                <li>
                                    Any looping statement, including range-based #(keyword:for)#
                                </li>
                                <li>
                                    Expressions which change the value of an object if the lifetime of that object began within the constant expression function.
                                </li>
                            </ul>
                            <p>
                                #(keyword:goto)# statements are forbidden in C++14 relaxed constexpr-declared functions.
                            </p>
                            <p>
                                Non-static member constexpr functions may be non-const.<br>
                                However these kind of functions can only modify a class member if that object's lifetime began within the constant expression evaluation.
                            </p>
                        </div>
                    </article>
                </section>

                <!-- <section>
                    <h2>Member initializers and aggregates (NSDMI)</h2>
                    <div class="ribbon cpp14"></div>
                    <div class="ribbon tobedefined"></div>
                    <article>
                        <div>
                            ???
                        </div>
                    </article>
                </section> -->

                <section>
                    <h2>Clarifying memory allocation (avoiding/fusing allocations)</h2>
                    <div class="ribbon cpp14"></div>
                    <div class="ribbon tobedefined"></div>
                    <article>
                        <div>
                            ???
                        </div>
                    </article>
                </section>

                <section>
                    <h2 data-category="language">[[deprecated]] attribute</h2>
                    <div class="ribbon cpp14"></div>
                    <div class="ribbon tobedefined"></div>
                    <article>
                        <div>
                            ???
                        </div>
                    </article>
                </section>

                <section>
                    <h2 data-category="language">Sized deallocation</h2>
                    <div class="ribbon cpp14"></div>
                    <div class="ribbon tobedefined"></div>
                    <article>
                        <div>
                            ???
                        </div>
                    </article>
                </section>

                <section>
                    <h2 data-category="language">Single quote as digit separator</h2>
                    <div class="ribbon cpp14"></div>
                    <div class="ribbon tobedefined"></div>
                    <article>
                        <div>
                            ???
                        </div>
                    </article>
                </section>

                <section>
                    <h2 data-category="stl">#(type:std::result_of)# and SFINAE</h2>
                    <div class="ribbon cpp14"></div>
                    <div class="ribbon tobedefined"></div>
                    <article>
                        <div>
                            ???
                        </div>
                    </article>
                </section>

                <section>
                    <h2 data-category="stl">#(keyword:constexpr)# for #(header:complex)#</h2>
                    <div class="ribbon cpp14"></div>
                    <div class="ribbon tobedefined"></div>
                    <article>
                        <div>
                            ???
                        </div>
                    </article>
                </section>

                <section>
                    <h2 data-category="stl">#(keyword:constexpr)# for #(header:chrono)#</h2>
                    <div class="ribbon cpp14"></div>
                    <div class="ribbon tobedefined"></div>
                    <article>
                        <div>
                            ???
                        </div>
                    </article>
                </section>

                <section>
                    <h2 data-category="stl">#(keyword:constexpr)# for #(header:array)#</h2>
                    <div class="ribbon cpp14"></div>
                    <div class="ribbon tobedefined"></div>
                    <article>
                        <div>
                            ???
                        </div>
                    </article>
                </section>

                <section>
                    <h2 data-category="stl">#(keyword:constexpr)# for #(header:initializer_list)#, #(header:utility)#, #(header:tuple)#</h2>
                    <div class="ribbon cpp14"></div>
                    <div class="ribbon tobedefined"></div>
                    <article>
                        <div>
                            ???
                        </div>
                    </article>
                </section>

                <section>
                    <h2 data-category="stl">Improved #(type:std::integral_constant)#</h2>
                    <div class="ribbon cpp14"></div>
                    <div class="ribbon tobedefined"></div>
                    <article>
                        <div>
                            ???
                        </div>
                    </article>
                </section>
                
                <section>
                    <h2 data-category="stl">User-defined literals for #(header:chrono)# and #(header:string)#</h2>
                    <div class="ribbon cpp14"></div>
                    <div class="ribbon tobedefined"></div>
                    <article>
                        <div>
                            ???
                        </div>
                    </article>
                </section>
                
                <section>
                    <h2>Null forward iterators</h2>
                    <div class="ribbon cpp14"></div>
                    <div class="ribbon tobedefined"></div>
                    <article>
                        <div>
                            ???
                        </div>
                    </article>
                </section>

                <section>
                    <h2 data-category="stl">#(type:std::quoted)#</h2>
                    <div class="ribbon cpp14"></div>
                    <div class="ribbon tobedefined"></div>
                    <article>
                        <div>
                            ???
                        </div>
                    </article>
                </section>

                <section>
                    <h2>Heterogeneous associative lookup</h2>
                    <div class="ribbon cpp14"></div>
                    <div class="ribbon tobedefined"></div>
                    <article>
                        <div>
                            ???
                        </div>
                    </article>
                </section>

                <section>
                    <h2 data-category="stl">#(type:std::integer_sequence)#</h2>
                    <div class="ribbon cpp14"></div>
                    <div class="ribbon tobedefined"></div>
                    <article>
                        <div>
                            ???
                        </div>
                    </article>
                </section>

                <section>
                    <h2 data-category="stl">#(type:std::shared_timed_mutex)#</h2>
                    <div class="ribbon cpp14"></div>
                    <div class="ribbon tobedefined"></div>
                    <article>
                        <div>
                            ???
                        </div>
                    </article>
                </section>

                <section>
                    <h2 data-category="stl">#(type:std::exchange)#</h2>
                    <div class="ribbon cpp14"></div>
                    <div class="ribbon tobedefined"></div>
                    <article>
                        <div>
                            ???
                        </div>
                    </article>
                </section>
                
                <section>
                    <h2>fixing #(keyword:constexpr)# member functions without #(keyword:const)#</h2>
                    <div class="ribbon cpp14"></div>
                    <div class="ribbon tobedefined"></div>
                    <article>
                        <div>
                            ???
                        </div>
                    </article>
                </section>

                <section>
                    <h2 data-category="stl">#(type:std::get&lt;T&gt;)#</h2>
                    <div class="ribbon cpp14"></div>
                    <div class="ribbon tobedefined"></div>
                    <article>
                        <div>
                            ???
                        </div>
                    </article>
                </section>

                <section>
                    <h2 data-category="stl">Dual-Range #(type:std::equal)#, #(type:std::is_permutation)#, #(type:std::mismatch)#</h2>
                    <div class="ribbon cpp14"></div>
                    <div class="ribbon tobedefined"></div>
                    <article>
                        <div>
                            ???
                        </div>
                    </article>
                </section>
            </section>
<!--
                   CCCCCCCCCCC                                 111     7777777777777
                 CCCCCCCCCCCCCC                              11111     7777777777777
                CCCCC       CCC                            1111111             77777
                CCCC                +++          +++      11  1111            7777
                CCCC                +++          +++          1111           7777
                CCCC            +++++++++++  +++++++++++      1111          7777
                CCCC            +++++++++++  +++++++++++      1111          7777
                CCCCC       CCC     +++          +++          1111         7777
                 CCCCCCCCCCCCCC     +++          +++          1111         7777
                   CCCCCCCCCCC                            111111111111     7777
-->
            <section>
                <section>
                    <h1>C++ 17</h1>
                    <nav style="font-size: 45%" data-auto="usability='core language usability', functionality='core language functionality', stl='standard library', misc='miscellaneous', preprocessor='preprocessor functionalities', deprecated='deprecated functionalities'"/>
                </section>

                <section>
                    <h2 data-category="usability">New auto rules for direct-list-initialization</h2>
                </section>

                <section>
                    <h2 data-category="usability">#(keyword:static_assert)# with no message</h2>
                </section>

                <section>
                    <h2 data-category="usability">#(keyword:typename)# in a template template parameter</h2>
                </section>

                <section>
                    <h2 data-category="usability">Nested namespace definition</h2>
                </section>

                <section>
                    <h2 data-category="usability">u8 character literals</h2>
                </section>

                <section>
                    <h2 data-category="usability">Allow constant evaluation for all non-type template arguments</h2>
                </section>

                <section>
                    <h2 data-category="functionality">Fold Expressions</h2>
                </section>

                <section>
                    <h2 data-category="deprecated">Removing some deprecated features</h2>
                    <article>
                    <p>
                        Removing trigraphs
                    </p>
                    <p>
                        Remove deprecated use of the #(keyword:register)# keyword
                    </p>
                    <p>
                        Remove deprecated operator++(bool)
                    </p>
                    <p>
                        Removing deprecated exception specifications
                    </p>
                    </article>
                </section>

                <section>
                    <h2 data-category="functionality">exception specifications part of the type</h2>
                    <article>
                        <p>
                            The exception specification of a function is now considered as a part of its type.
                        </p>
                        <p>
                            A prvalue of type "pointer to noexcept function" can be converted to a prvalue of type "pointer to function".
                            The result is a pointer to the function.
                        </p>
                        <p>
                            A prvalue of type "pointer to member of type noexcept function" can be converted to a prvalue of type "pointer to member of type function".
                            The result points to the member function.
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category="functionality">Aggregate initialization of classes with base classes</h2>
                </section>

                <section>
                    <h2 data-category="usability">Lambda capture of *this</h2>
                </section>

                <section>
                    <h2 data-category="functionality">Dynamic memory allocation for over-aligned data</h2>
                </section>

                <section>
                    <h2 data-category="usability">Unary fold expressions & empty parameter packs</h2>
                </section>

                <section>
                    <h2 data-category="preprocessor">__has_include in preprocessor conditionals</h2>
                </section>

                <section>
                    <h2 data-category="usability">Template argument deduction for classes</h2>
                    <article>
                        Template argument deduction for class templates
                    </article>
                </section>

                <section>
                    <h2 data-category="usability">Non-type template parameters with auto type</h2>
                </section>

                <section>
                    <h2 data-category="functionality">Guaranteed copy elision</h2>
                </section>

                <section>
                    <h2 data-category="usability">New specification for inheriting constructors</h2>
                </section>

                <section>
                    <h2 data-category="usability">Direct-list-initialization of enumerations</h2>
                    <article>
                        The bug of C++17 specification...
                    </article>
                </section>

                <section>
                    <h2 data-category="usability">Stricter expression evaluation order</h2>
                </section>

                <section>
                    <h2 data-category="usability">constexpr lambda expressions</h2>
                </section>

                <section>
                    <h2 data-category="usability">Differing begin & end types in range-based for</h2>
                </section>

                <section>
                    <h2 data-category="functionality">#(attribute:fallthrough)#</h2>
                    <p>
                        <!-- [[fallthrough]] attribute -->
                        <article style="font-size:70%">
                            The attribute-token #(attribute:fallthrough)# may be applied to a null statement that precedes a case of default label statement within a switch statement.
                            <cppblock style="font-size:60%">
                                void f(int n) {
                                    void g(), h(), i();
                                    switch (n) {
                                    case 1:
                                    case 2: // OK
                                        g();
                                        [[fallthrough]];
                                    case 3: // OK
                                        h();
                                    case 4:
                                        i();
                                        [[fallthrough]]; // error: annotation does not directly precede switch label
                                        j();
                                    case 5: // warning: unannotated fall-through between switch labels
                                        k();
                                        [[fallthrough]]; // error: annotation does not directly precede switch label
                                    }
                                }
                            </cppblock>
                            To activate on clang:  <i>-Wimplicit-fallthrough</i>
                        </article>
                    </p>
                    <!-- <div style="position: absolute; top:0; left: 0; overflow:hidden; height:100%; width: 100%;">
                        <div style="background-color: rgba(0, 128, 0, 0.5); width: 300px; display: inline-block; transform: translate(-50%, -50%) rotate(-45deg); font-size: 50%; font-weight: bold; position: absolute; top: 60px; left: 60px;">
                            MANDATORY
                        </div>
                    </div> -->
                    <div class="ribbon green topleft"><div>MANDATORY</div></div>
                    <div class="ribbon yellow topright"><div>RECOMMENDED</div></div>
                    <!-- <div style="position: absolute; top:0; right: 0; overflow:hidden; height:100%; width: 100%;">
                        <div style="background-color: rgba(234, 238, 28, 0.5); width: 300px; display: inline-block; transform: translate(50%, -50%) rotate(45deg); font-size: 50%; font-weight: bold; position: absolute; top: 60px; right: 60px;">
                            RECOMMENDED
                        </div>
                    </div> -->
                </section>

                <section>
                    <h2 data-category="functionality">About [[attributes]]</h2>
                    <p>
                        [[nodiscard]] attribute
                    </p>
                    <p>
                        [[maybe_unused]] attribute
                    </p>
                    <p>
                        Ignore unknown attributes
                    </p>
                    <p>
                        Attributes for namespaces and enumerators
                    </p>
                    <p>
                        Using attribute namespaces without repetition
                    </p>
                </section>

                <section>
                    <h2 data-category="functionality">Structured Bindings</h2>
                </section>

                <section>
                    <h2 data-category="usability">Pack expansions in using-declarations</h2>
                </section>

                <section>
                    <h2 data-category="functionality">Hexadecimal floating-point literals</h2>
                </section>

                <section>
                    <h2 data-category="functionality">constexpr if statements</h2>
                </section>

                <section>
                    <h2 data-category="functionality">init-statements for if and switch</h2>
                </section>

                <section>
                    <h2 data-category="functionality">Inline variables</h2>
                </section>

                <section>
                    <h2 data-category="usability">DR: Matching of template template-arguments excludes compatible templates</h2>
                </section>

                <section>
                    <h2 data-category="stl"><span data-no-clang>Standardization of Parallelism TS</span></h2>
                    <article>
                        #(header:execution_policy)#
                    </article>
                </section>

                <section>
                    <h2 data-category="stl">std::uncaught_exceptions()</h2>
                </section>

                <section>
                    <h2 data-category="stl"><span data-no-clang>Splicing Maps and Sets</span></h2>
                </section>

                <section>
                    <h2 data-category="stl">Improving std::pair and std::tuple</h2>
                </section>

                <section>
                    <h2 data-category="stl">std::shared_mutex (untimed)</h2>
                </section>

                <section>
                    <h2 data-category="stl"><span data-no-clang>Elementary string conversions</span></h2>
                    <article>
                        #(header:charconv)#<br>
                        std::from_chars<br>
                        std::to_chars
                    </article>
                </section>

                <section>
                    <h2 data-category="stl">std::string_view</h2>
                </section>

                <section>
                    <h2 data-category="stl"><span data-no-clang>std::filesystem</span></h2>
                </section>
            </section>
        </div>
    </div>

    <!--
        GUIDELINES:
        parameter non-const ref parameter prohibited => use GSL non_null<pointer>
    -->

    <script src="revealjs/lib/js/head.min.js"></script>
    <script src="revealjs/js/reveal.js"></script>
    <script src="mod/mod4revealjs.js"></script>
    <script>
        // More info about config & dependencies:
        // - https://github.com/hakimel/reveal.js#configuration
        // - https://github.com/hakimel/reveal.js#dependencies
        Reveal.initialize({
            dependencies: [
                { src: 'revealjs/plugin/markdown/marked.js' },
                { src: 'revealjs/plugin/markdown/markdown.js' },
                { src: 'revealjs/plugin/notes/notes.js', async: true },
                { src: 'revealjs/plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); initAfterHighlightJS(); } },
            ],
            width: 1280,
            height: 720,
            margin: -0.010,
            // margin: 0.025,
            history: true,
            mouseWheel: true,
            center: false,
            display: 'block',
            transition: 'none',
        });
    </script>
</body>

</html>
