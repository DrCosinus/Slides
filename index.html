<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Shake // Modern C++ Features</title>

    <link rel="stylesheet" href="revealjs/css/reveal.css">
    <link rel="stylesheet" href="revealjs/css/theme/white.css">
    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="revealjs/lib/css/zenburn.css">
    <link rel="stylesheet" href="mod/mod4revealjs.css">
    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'revealjs/css/print/pdf.css' : 'revealjs/css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>

<body>
    <div class="reveal">
        <div class="slides">
            <section>
                <h2>Modern C++ Features</h2>
                <h3>Past / Present / Future</h3>
            </section>
<!--
                   CCCCCCCCCCC                                 111          111    
                 CCCCCCCCCCCCCC                              11111        11111    
                CCCCC       CCC                            1111111      1111111    
                CCCC                +++          +++      11  1111     11  1111    
                CCCC                +++          +++          1111         1111    
                CCCC            +++++++++++  +++++++++++      1111         1111    
                CCCC            +++++++++++  +++++++++++      1111         1111    
                CCCCC       CCC     +++          +++          1111         1111    
                 CCCCCCCCCCCCCC     +++          +++          1111         1111    
                   CCCCCCCCCCC                            111111111111 111111111111
-->
            <section>
                <section id="cpp11">
                    <h1>C++ 11</h1>
                    <nav data-auto="usability='core language usability', functionality='core language functionality', stl='standard library', rtperf='core language runtime performance', misc='miscellaneous'"/>
                </section>

                <section>
                    <h2 data-category=functionality>#(keyword:alignas)# and #(keyword:alignof)#</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon whenneeded"></div>
                    <aside class="notes">
                        <ul>
                            <li>Current usage: not used a lot</li>
                            <li>Current directive: almost never recommended</li>
                            <li>Future directive: To use as soon as necessary</li>
                        </ul>
                    </aside>
                    <article style="font-size: 110%">
                        <p>
                            C++11 allows variable alignment to be queried and controlled with #(keyword:alignof)# and #(keyword:alignas)#.
                        </p>
                        <p style="display: none;">
                            The #(keyword:alignof)# operator takes the type and returns the power of 2 byte boundary on which the type instances must be allocated (as a #(type:std::size_t)#).
                        </p>
                        <p style="display: none;">
                            When given a reference type alignof returns the referenced type's alignment; for arrays it returns the element type's alignment.
                        </p>
                        <p>
                            The #(keyword:alignas)# specifier controls the memory alignment for a variable. The specifier takes a constant or a type; when supplied a type #(code:alignas(T))# is shorthand for #(code:alignas(alignof(T)))#.
                        </p>
                        <p>
                            For example, to specify that a char array should be properly aligned to hold a float:
                            <cppblock>
                                alignas(float) unsigned char c[sizeof(float)];
                            </cppblock>
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category=stl>atomic operations</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon whenneeded"></div>
                    <aside class="notes">
                        <ul>
                            <li>Current usage: little used</li>
                            <li>Current directive: almost never recommended</li>
                            <li>Future directive: To use as soon as necessary</li>
                        </ul>
                    </aside>
                    <article style="font-size: 110%">
                        <p>
                            C++11 introduces the atomic operations library<br>needed for lock-free concurential programmation.
                        </p>
                        <p>
                            Every atomic operation is not splittable by any<br>other atomic operation involving the same object.
                        </p>
                        <p>
                            Atomic objects are "data races"-free.
                        </p>
                        <p>
                            The atomic operations are defined in the header file #(header:atomic)#.
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category=usability>#(keyword:auto)#</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon recommended"></div>
                    <aside class="notes">
                        <ul>
                            <li>Current usage: very used</li>
                            <li>Current directive: recommended</li>
                            <li>Future directive: To use as soon as possible</li>
                        </ul>
                    </aside>
                    <article style="font-size: 110%">
                        <p>
                            C++11 allows type inference.
                        </p>
                        <p>
                            The definition of a variable with an explicit initialization can use the #(keyword:auto)# keyword.<br>
                        </p>
                        <p>
                            <p>
                                This creates a variable of the specific type of the initializer:
                            </p>
                            <cppblock style="font-size: 50%">
                                auto some_strange_callable_type = std::bind(&amp;some_function, _2, _1, some_object);
                                auto other_variable = 5;
                            </cppblock>
                        </p>
                        <p style="font-size: 150%;">
                            Almost always #(keyword:auto)#?
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category=usability>#(keyword:decltype)#</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon whenneeded"></div>
                    <aside class="notes">
                        <ul>
                            <li>Current usage: uncommon</li>
                            <li>Current directive: rarely needed</li>
                            <li>Future directive: To use as soon as necessary</li>
                        </ul>
                    </aside>
                    <article>
                        <p>
                            The keyword #(keyword:decltype)# can be used to determine the type of expression at compile-time.
                        </p>
                        <p>
                            <cppblock>
                                unsigned int some_int;
                                decltype(some_int) other_integer_variable = 5;
                            </cppblock>
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category="rtperf">#(keyword:constexpr)#</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon recommended"></div>
                    <aside class="notes">
                        <ul>
                            <li>Current usage: used</li>
                            <li>Current directive: sometimes recommended</li>
                            <li>Future directive: To use</li>
                        </ul>
                    </aside>
                    <article style="font-size: 70%">
                        <p>
                            C++11 introduced the keyword constexpr, which allows the user to guarantee that a function or object constructor is a compile-time constant.
                            So, a constant expression is allowed to contain a function call or object constructor (the compiler can verify that it is compile-time constant).
                        </p>
                        <p>
                            In C++11, there are some limitations for constexpr functions and constructors (non-void return type, no variable declarations or new types in the function body, only one return statement).
                        </p>
                        <p>
                            If it is called with not constant expression arguments, the call behaves as if the function were not constexpr, and the resulting value is not a constant expression.
                            Likewise, if the expression in the return statement of a constexpr function does not evaluate to a constant expression for a given invocation, the result is not a constant expression.
                            <cppblock style="font-size: 80%">
                                constexpr int siz() { return 42; }
                                int array[siz() + 17]; // illformed if siz() is not constexpr
                                template&lt;int I&gt; struct Bar {};
                                Bar&lt;siz()&gt; bar;  // illformed if siz() is not constexpr
                            </cppblock>
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category=functionality>Defaulted &amp; deleted functions</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon recommended"></div>
                    <aside class="notes">
                        Current usage: used<br/>
                        Current directive: often recommended<br/>
                        Future directive: to use whenever possible
                    </aside>
                    <article>
                        <p>
                            C++11 allows the explicit defaulting and deleting of special member functions.
                        </p>
                        <p>
                            <cppblock style="font-size: 80%">
                                struct Foo
                                {
                                    Foo() = default; // explicit instantiantion of default constructor
                                    Foo(int _value);
                                };
                                struct NonCopyable
                                {
                                    NonCopyable() = default;
                                    NonCopyable(const NonCopyable&amp;) = delete;
                                    NonCopyable&amp; operator=(const NonCopyable&amp;) = delete;
                                };
                            </cppblock>
                        </p>
                    </article>
                </section>
                
                <section>
                    <h2 no-toc>Defaulted &amp; deleted functions</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon recommended"></div>
                    <article>
                        <p>
                            The #(code:= delete)# specifier can be used to prohibit calling any function, which can be used to disallow calling a member function with particular parameters (and to guard against implicit cast).
                        </p>
                        <p>
                            <cppblock style="font-size: 90%;">
                                struct Foo
                                {
                                    Foo(double) {}
                                    Foo(int) = delete;                      // &lt;== guard from conversion from int
                                };
                                struct Bar
                                {
                                    Bar(double) {}
                                    template&lt;typename T&gt; Bar(T) = delete;  // &lt;== guard from any conversion but double
                                };
                            </cppblock>
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category=usability>Delegating constructors</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon recommended"></div>
                    <aside class="notes">
                        Current usage: not used a lot<br/>
                        Current directive: sometimes recommended<br/>
                        Future directive: To be used as soon as possible
                    </aside>
                    <article>
                        <p>
                            C++11 allows constructors to call other peer constructors.
                        </p>
                        <p>
                            <cppblock>
                                struct Foo
                                {
                                    Foo(int _value) : value_(_value) {}
                                    Foo() : Foo(42) {} // &lt;== this constructor calls the other one
                                private:
                                    int value_;
                                };
                            </cppblock>
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category=usability>inheriting constructors</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon recommended"></div>
                    <aside class="notes">
                        Current usage: not used a lot<br/>
                        Current directive: sometimes recommended<br/>
                        Future directive: to be used as soon as possible
                    </aside>
                    <article>
                        <p>
                            C++11 allows a class to specify that base class constructors will be inherited.
                        </p>
                        <p>
                            <cppblock style="font-size: 70%">
                                struct Parent
                                {
                                    explicit Parent(int _value) : value_{_value} {}
                                    Parent() : value_(-1) {}
                                    Parent(int _value1, int _value2) : value_{_value1 + _value2} {}
                                private:
                                    int value_;
                                };
                                struct Child : Parent
                                {
                                    using Parent::Parent; // &lt;== inheriting all constructors of Parent
                                };
                                ...
                                Child child0, child1{14, 28}, child2{17}; // child values are respectively: -1 42 17
                            </cppblock>
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category=usability>#(keyword:nullptr)#</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon mandatory"></div>
                    <aside class="notes">
                        <summary data-category="Current usage">very used</summary>
                        <summary data-category="Current directive">mandatory</summary>
                        <summary data-category="Future directive">mandatory</summary>
                    </aside>
                    <article style="font-size: 120%;">
                        <p>
                            C++11 introduces a new keyword to serve as a distinguished null pointer constant: #(keyword:nullptr)#.
                        </p>
                        <p>
                            It is of type #(type:std::nullptr_t)#, which is implicitly convertible and comparable to any pointer type or pointer-to-member type.
                        </p>
                        <p>
                            It is not implicitly convertible or comparable to integral types, except for #(type:bool)#.
                        </p>
                </article>
                </section>

                <section>
                    <h2 data-category=functionality>#(keyword:static_assert)#</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon recommended"></div>
                    <aside class="notes">
                        <summary data-category="Current usage">used</summary>
                        <summary data-category="Current directive">recommended</summary>
                        <summary data-category="Future directive">recommended</summary>
                    </aside>
                    <article>
                        <p style="font-size: 120%">
                            C++11 introduces a new way to test assertions<br>at compile-time,using the new keyword #(keyword:static_assert)#.
                        </p>
                        <p>
                            <cppblock style="font-size: 60%">
                                static_assert((MC_PI > 3.14) && (MC_PI < 3.15), "MC_PI is inaccurate!");

                                template&lt;typename T>
                                struct Check
                                {
                                static_assert(sizeof(int) <= sizeof(T), "T is not big enough!");
                                };

                                template&lt;typename INTEGRAL>
                                INTEGRAL foo(INTEGRAL x, INTEGRAL y)
                                {
                                static_assert(std::is_integral&lt;INTEGRAL>::value,
                                    "foo() parameter must be an integral type.");
                                }
                            </cppblock>
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category=usability>Strongly-typed enumerations</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon recommended"></div>
                    <aside class="notes">
                        <summary data-category="Current usage">used if not to be serializable</summary>
                        <summary data-category="Current directive">recommended</summary>
                        <summary data-category="Future directive">recommended</summary>
                    </aside>
                    <article style="text-align: left; font-size: 60%;">
                        <p>
                            C++11 provides strongly-typed enumerations:
                            <ul>
                                <li>it can not be used for/assigned to/compared with another enumeration.</li>
                                <li>it is not implicitly converted to #(type:int)#.</li>
                                <li>there is no risk of name collisions due to the need to use scope resolution operator to access values,</li>
                                <li>the underlying type can be overridden to a different integral type (#(type:int)# by default)</li>
                            </ul>
                        </p>
                        <p>
                            Forward-declaring enums is possible in C+11. As long as the size of the enumeration is specified either implicitly or explicitly, it can be forward-declared:
                            <cppblock style=" font-size: 70%;">
                                enum Enum1;                      // Invalid in C++03 and C++11; the underlying type cannot be determined.
                                enum Enum2 : unsigned int;       // Valid in C++11, the underlying type is specified explicitly.
                                enum class Enum3;                // Valid in C++11, the underlying type is int.
                                enum class Enum4 : unsigned int; // Valid in C++11.
                                enum Enum2 : unsigned short;     // Invalid in C++11, because Enum2 was formerly declared with a different underlying type.
                            </cppblock>
                        </p>
                        <p>
                            C++11 allows the forward-declaration, the use of the scope resolution operator, and the choice of the underlying type <strong>even for old-style enumerations</strong>.
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category=functionality>Template aliases</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon mandatory"></div>
                    <aside class="notes">
                        <summary data-category="Current usage">used => #(keyword:typedef)# is deprecated</summary>
                        <summary data-category="Current directive">recommended</summary>
                        <summary data-category="Future directive">recommended</summary>
                    </aside>
                    <article>
                        <p>The keyword #(keyword:typedef)# is deprecated.</p>
                        C++11 allows to create templated synonym for template type.
                        The template parameters of the synonym can be different of the template parameters of the original type.<br>
                        <cppblock style="font-size: 90%">
                            template&lt;typename First, typename Second, int Third>
                            class SomeType;

                            template&lt;typename Second>
                            using TypedefName = SomeType&lt;OtherType, Second, 5>;
                        </cppblock>
                        The syntax is generalized to define any synonym type in a more intuitively readable manner.
                        <cppblock style="font-size: 90%">
                            typedef void (*OldFunctionType)(double);  // <== old style. tricky to read 

                            using NewFunctionType = void (*)(double); // <== new style. more obvious
                        </cppblock>
                    </article>
                </section>

                <section>
                    <h2 data-category=functionality>variadic templates</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon whenneeded"></div>
                    <aside class="notes">
                        <summary data-category="Current usage">very little used</summary>
                        <summary data-category="Current directive">never recommended</summary>
                        <summary data-category="Future directive">recommended for specific use</summary>
                    </aside>
                    <article>
                        In C++11, templates can take variable numbers of template parameters.<br>
                        This also allows the definition of type-safe variadic functions
                    </article>
                </section>

                <section>
                    <h2 data-category=functionality>extern templates</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon whenneeded"></div>
                    <aside class="notes">
                        <summary data-category="Current usage">very little used</summary>
                        <summary data-category="Current directive">very little recommended</summary>
                        <summary data-category="Future directive">recommended if needed</summary>
                    </aside>
                    <article>
                        C++11 provdied a syntax to tell the compiler <span style="text-decoration: underline; font-weight: bolder">not</span> to instantiate the template in this translation unit.
                    </article>
                </section>
    
                <section>
                    <h2 data-category=functionality>Thread-local storage</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon whenneeded"></div>
                    <aside class="notes">
                        <summary data-category="Current usage">...</summary>
                        <summary data-category="Current directive">...</summary>
                        <summary data-category="Future directive">...</summary>
                    </aside>
                    <article>
                        C++11 introduces the keyword #(keyword:thread_local)#.<br>
                        Any object which could have static storage duration may be given thread-local duration instead.<br>
                        Each thread holds its own copy of such variables.<br>
                        Lifetime of each copies of these variables is bound to the thread holding them.
                    </article>
                </section>

                <section>
                    <h2 data-category=usability>unrestricted unions</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon whenneeded"></div>
                    <aside class="notes">
                        <summary data-category="Current usage">...</summary>
                        <summary data-category="Current directive">...</summary>
                        <summary data-category="Future directive">...</summary>
                    </aside>
                    <article>
                        C++11 lifts some restrictions on what types can me members of a #(keyword:union)#.
                        Unions can now have member with non trivial special member functions but it must be <u>manually defined</u>.
                        <cppblock style="font-size:65%;">
                            #include &lt;new> // Needed for placement 'new'.
                            struct Point {
                                Point() {}
                                Point(int _x, int _y): x_(_x), y_(_y) {}
                                int x_, y_;
                            };
                            union U {
                                int z;
                                double w;
                                Point p;
                                U() {} // Due to the Point member, a constructor definition is needed.
                                U(const Point& pt) : p(pt) {} // Construct Point object using initializer list.
                                U& operator=(const Point& pt) { new(&p) Point(pt); return *this; } // Assign Point object using placement 'new'.
                            };
                        </cppblock>
                    </article>
                </section>

                <section>
                    <h2 data-category=usability>non-static data member initializers</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon recommended"></div>
                    <aside class="notes">
                        <summary data-category="Current usage">rarely used</summary>
                        <summary data-category="Current directive">sometimes recommended</summary>
                        <summary data-category="Future directive">recommended</summary>
                    </aside>
                    <article>
                        C++11 allow to assign a default value to non-static data members.
                        Each constructor will initialize these members with the default value only if it does not override the initialization with its own.
                    </article>
                    <cppblock style="font-size:60%">
                        struct Foo
                        {
                            Foo() {}             // value_ initialized with 509
                            explicit Foo(int _value)
                             : value_(_value) {} // value_ initialized with given parameter
                        private:
                            int value_ = 509;
                        };
                    </cppblock>
                </section>

                <section>
                    <h2 data-category=usability>Range-for loop</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon recommended"></div>
                    <aside class="notes">
                        <summary data-category="Current usage">very use</summary>
                        <summary data-category="Current directive">recommended</summary>
                        <summary data-category="Future directive">recommended</summary>
                    </aside>
                    <article>
                        C++11 extends the syntax of the #(keyword:for)# statement to allow for easy iteration over a range of elements.
                        <cppblock>
                            int my_array[5] = {1, 2, 3, 4, 5};
                            // double the value of each element in my_array:
                            for (int& x : my_array)
                            {
                                x *= 2;
                            }
                        </cppblock>
                    </article>
                </section>

                <section>
                    <h2 data-category=usability>lambda expressions</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon whenneeded"></div>
                    <aside class="notes">
                        <summary data-category="Current usage">very use</summary>
                        <summary data-category="Current directive">recommended</summary>
                        <summary data-category="Future directive">recommended</summary>
                    </aside>
                    <article>
                        <p>
                            C++11 provides the ability to create anonymous functions, called lambda functions.
                        </p>
                        <p>
                            These are defined as follows: #(code:[](int x, int y) -> int { return x + y; })#
                        </p>
                        <p>
                            The return type can be omitted when all #(keyword:return)# returns the same type: #(code:[](int x, int y) { return x + y; })#
                        </p>
                        <p>
                            The type of a lambda is unspecified. User must use #(keyword:auto)#:
                            #(code:auto lambda = [](int x, int y) { return x + y; })#
                        </p>
                        <p>
                            A lambda can capture variables (by copy or by reference):
                            #(code:[copy, &amp;ref](int x) { ref = x + copy; })#
                        </p>
                        <p>
                            A lamba which capture no variable can be converted into a function pointer:
                            <cppblock>
                                int f(int(*_callback)(int, int)) { return _callback( 17, 25 ); }
                                int r = f([](int x, int y){ return x + y; });
                            </cppblock>
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category=usability>#(keyword:override)# and #(keyword:final)#</h2>
                    <div class="ribbon cpp11"></div>
                    <div class="ribbon mandatory"></div>
                    <aside class="notes">
                        <summary data-category="Current usage">compilation error if #(keyword:override)# is missing</summary>
                        <summary data-category="Current directive">#(keyword:override)# is mandatory</summary>
                        <summary data-category="Future directive">#(keyword:override)# is mandatory</summary>
                    </aside>
                    <article>
                        <p>
                            #(keyword:override)# is mandatory
                        </p>
                        <p>
                            C++11 provides syntax to prevent from bad virtual function overriding.
                        </p>
                        <p>
                            The #(keyword:override)# special identifier means that the compiler will check the base classes to see if there is a vistual function with this exact signature.
                            If there is not, the compiler will indicate an error.
                        </p>
                        <cppblock style="font-size: 80%">
                            struct Base
                            { virtual void foo(float);
                            };
                            struct Derived : Base
                            { void foo(int) override; // error: doesn't override a base class method
                            };
                        </cppblock>
                        <p>
                            C+11 also adds the ability to prevent inheriting from classes or simply preventing overriding method in derived classes.
                            This is done with special identifier #(keyword:final)#.
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category="rtperf">rvalue reference and move semantics</h2>
                    <header data-category="core language runtime performance">
                        <summary data-category="Current usage">use</summary>
                        <summary data-category="Current directive">recommended if needed</summary>
                        <summary data-category="Future directive">recommended if needed</summary>
                    </header>
                    <article>
                        <p>
                            C++11 adds a new non-const reference type called an rvalue reference, identified by #(code:T&&)#.
                            This refers to temporaries that are permitted to be modified after they are initialized, for the purpose of allowing "move semantics".
                        </p>
                        <p>
                            For safety reasons, some restrictions are imposed. A named variable will never be considered to be an rvalue even if it is declared as such.
                            To get an rvalue, the function template #(code:std::move)# should be used.
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category=functionality>Raw string literals</h2>
                    <header>
                        <summary data-category="Current usage">never used</summary>
                        <summary data-category="Current directive">never think about them</summary>
                        <summary data-category="Future directive">to be considered if needed</summary>
                    </header>
                    <article>
                        C++11 provides a raw string literal:
                        <p style="background-color: rgba(0,0,0,0.3); margin: 0 13%;">
                            <cppblock>
                                R"(The String Data \ Stuff " )"
                            </cppblock>
                            In this first case, everything between the #(code:"()# and the #(code:)")# is part of the string.<br>
                            The #(code:")# and #(code:\)# characters do not need to be escaped.
                        </p>
                        <p style="background-color: rgba(0,0,0,0.3);">
                            <cppblock>
                                R"delimiter(The String Data \ Stuff " )delimiter"
                            </cppblock>
                            In this second case, the #(code:"delimiter()# starts the string, and it ends only when #(code:)delimiter")# is reached.
                            The string #(code:delimiter)# can be any string up to 16 characters in length, including the empty string.
                            This string cannot contain spaces, control characters, #(code:()#, #(code:))#, or the #(code:\)# character.
                            Using this delimiter string allows the user to have #(code:))# characters within raw string literals.
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category=functionality>User-defined literals</h2>
                    <header>
                        <summary data-category="Current usage">very little used</summary>
                        <summary data-category="Current directive">rarely recommended</summary>
                        <summary data-category="Future directive">to be considered if needed</summary>
                    </header>
                    <article>
                        <p>
                            C++11 enables the user to define new kinds of literal modifiers that will construct objects based on the string of characters that the literal modifies.
                            Transformation of literals is redefined into two distinct phases: raw and cooked.
                            A raw literal is a sequence of characters of some specific type, while the cooked literal is of a separate type.
                            The C++ literal #(code:1234)#, as a raw literal, is this sequence of characters #(code:'1')#, #(code:'2')#, #(code:'3')#, #(code:'4')#.
                            As a cooked literal, it is the integer 1234.
                            The C++ literal #(code:0xA)# in raw form is #(code:'0')#, #(code:'x')#, #(code:'A')#, while in cooked form it is the integer 10.
                        </p>
                        <p>
                            All user-defined literals are suffixes; defining prefix literals is not possible.
                            All suffixes starting with any character except underscore (#(code:_)#) are reserved by the standard.
                            Thus, all user-defined literals must have suffixes starting with an underscore (#(code:_)#).
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category=usability>Explicit conversion operators</h2>
                    <header>
                        <summary data-category="Current usage">used</summary>
                        <summary data-category="Current directive">recommended</summary>
                        <summary data-category="Future directive">recommended</summary>
                    </header>
                    <article>
                        In C++11, the #(keyword:explicit)# keyword can now be applied to conversion operators.
                        As with constructors, it prevents using those conversion functions in implicit conversions.
                        However, language contexts that specifically need a boolean value (the conditions of if-statements and loops, and operands to the logical operators) count as explicit conversions and can thus use a #(type:bool)# conversion operator.
                    </article>
                </section>

                <section>
                    <h2 data-category=functionality>#(keyword:noexcept)#</h2>
                    <header>
                        <summary data-category="Current usage">almost not used</summary>
                        <summary data-category="Current directive">no recommendation</summary>
                        <summary data-category="Future directive">???</summary>
                    </header>
                    <article>
                        Compile-time specification of non-exception-throwing functions is available with the #(keyword:noexcept)# keyword, which is useful for optimization.
                    </article>
                </section>

                <section>
                    <h2 data-category=usability>Trailing function return types</h2>
                    <header>
                        <summary data-category="Current usage">almost always used</summary>
                        <summary data-category="Current directive">recommended</summary>
                        <summary data-category="Future directive"><span style="color: red;">abandoned</span></summary>
                    </header>
                    <article>
                        C++11 introduced trailing-return-type function declaration syntax so the return type can depend on function parameters:
                        <cppblock style="font-size: 80%">
                            template&lt;typename Lhs, typename Rhs>
                            auto adding_func(const Lhs &lhs, const Rhs &rhs) -> decltype(lhs+rhs) {return lhs + rhs;}
                        </cppblock>
                        This syntax can be used for classic function declarations and definitions.
                        <cppblock style="font-size: 80%">
                            struct SomeStruct
                            {
                                auto func_name(int x, int y) -> int;
                            };
                            auto SomeStruct::func_name(int x, int y) -> int
                            {
                                return x + y;
                            }
                        </cppblock>
                    </article>
                </section>

                <section>
                    <h2 data-category=functionality>Type #(type:long long int)#</h2>
                    <header>
                        <summary data-category="Current usage">almost not used</summary>
                        <summary data-category="Current directive">no recommendation</summary>
                        <summary data-category="Future directive">???</summary>
                    </header>
                    <article>
                        C++11 adds a new integer type #(type:long long int)# to address the problem that type #(type:long int)# having size of 64 bits on some popular implementations and 32 bits on others.
                        The new type is guaranteed to be at least as large as a long int, and have no fewer than 64 bits.
                    </article>
                </section>

                <section>
                    <h2 data-category=usability>Uniform initialization</h2>
                    <header>
                        <summary data-category="Current usage">used</summary>
                        <summary data-category="Current directive">sometimes recommended</summary>
                        <summary data-category="Future directive">recommended</summary>
                    </header>
                    <article style="font-size: 50%">
                        C++11 provides a syntax that allows for fully uniform type initialization that works on any object.
                        It expands on the initializer list syntax:
                        <div style="column-count: 2; font-size: 90%;">
                            <cppblock>
                                struct BasicStruct
                                {
                                    int x;
                                    double y;
                                };
                                struct AltStruct
                                {
                                    AltStruct(int x, double y) : x_{x}, y_{y}
                                    {}
                                private:
                                    int x_;
                                    double y_;
                                };
                                BasicStruct var1{5, 3.2};
                                AltStruct var2{2, 4.3};
                            </cppblock><br>
                            <cppblock>
                                struct IdString
                                {
                                    std::string name;
                                    int identifier;
                                };
                                
                                IdString get_string()
                                {
                                    return {"foo", 42}; //Note the lack of explicit type.
                                }
                            </cppblock>
                        </div>

                    </article>
                </section>


                <section>
                    <h2>Variadic macros</h2>
                    <header>
                        <summary data-category="Current usage">Used in very specific cases</summary>
                        <summary data-category="Current directive">Very rarely needed</summary>
                        <summary data-category="Future directive">only when you have no choice</summary>
                    </header>
                    <article>
                        <cppblock>
                            #define FOO(...) fprintf(stderr, __VA_ARGS__)
                            #define BAR(...) puts(#__VA_ARGS__)
                            #define QUZ(check, ...) ((check)?puts(#check):printf(__VA_ARGS__))
                            FOO("a = %d\n", a);
                            BAR(First, second and third);
                            QUZ(x>z, "x is %d and y is %d", x, y);
                        </cppblock>
                        becomes after the preprocessor pass
                        <cppblock>
                            fprintf(stderr, "a = %d\n", a);
                            puts("First, second and third");
                            ((x>z)?puts("x>z"):printf("x is %d and y is %d", x, y))
                        </cppblock>
                    </article>
                </section>

                <section>
                    <h2 data-category=usability>Right angle bracket</h2>
                    <article>
                        C++11 improves the specification of the parser so that multiple right angle brackets will be interpreted as closing the template argument list where it is reasonable.
                        This can be overridden by using parentheses around parameter expressions using the <q>></q>, <q>>=</q> or <q>>></q> binary operators:
                        <cppblock style="font-size: 90%">
                            template&lt;bool Test> class SomeType;
                            std::vector&lt;SomeType&lt;1>2>> x1;  // Interpreted as a std::vector of SomeType&lt;true>,
                                // followed by "2 >> x1", which is not valid syntax for a declarator. 1 is true.
                            std::vector&lt;SomeType&lt;(1>2)>> x1;  // Interpreted as std::vector of SomeType&lt;false>,
                                // followed by the declarator "x1", which is valid C++11 syntax. (1>2) is false.
                        </cppblock>
                    </article>
                </section>

                <section>
                    <h2 data-category=stl>STL</h2>
                    <article>
                        <ul>
                            <li>hashtables: #(type:std::unordered_set)#, #(type:std::unordered_map)#, ...</li>
                            <li>Type traits for meta-programming: #(type:std::enable_if)#, #(type:std::conditional)#, ...</li>
                            <li>#(code:std::begin)#, #(code:std::end)#</li>
                            <li>#(type:std::reference_wrapper)#</li>
                            <li>Extensible random number facility</li>
                            <li>Threading facilities</li>
                            <li>Polymorphic wrappers for function objects: #(type:std::function)#</li>
                        </ul>
                    </article>
                </section>

                <section>
                    <h2 data-category=stl>smart pointers</h2>
                    <header>
                        <summary data-category="Current usage">use</summary>
                        <summary data-category="Current directive">#(type:unique_ptr)# recommended</summary>
                        <summary data-category="Future directive">recommended</summary>
                    </header>
                    <article>
                        C++11 provides #(type:std::shared_ptr)#, #(type:std::weak_ptr)#, #(type:std::unique_ptr)#
                        <p>#(type:std::auto_ptr)# is deprecated.</p>
                    </article>
                </section>
    
                <section>
                    <h2 data-category=stl>Regular expressions</h2>
                    <header>
                        <summary data-category="Current usage">never used</summary>
                        <summary data-category="Current directive">never think about them</summary>
                        <summary data-category="Future directive">to be considered if needed</summary>
                    </header>
                    <article>
                        The new library, defined in the new header #(header:regex)#, is made of a couple of new classes:
                        <ul>
                            <li>regular expressions are represented by instance of the template class #(type:std::regex)#,</li>
                            <li>occurences are represented by instance of the template class #(type:std::match_results)#.</li>
                        </ul>
                        <p>
                            The function #(code:std::regex_search)# is used for searching, and #(code:std::regex_replace)# is used for replacing.
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category=stl>#(type:std::tuple)#</h2>
                    <header>
                        <summary data-category="Current usage">quite never used</summary>
                        <summary data-category="Current directive">never recommended</summary>
                        <summary data-category="Future directive">recommended (see c++17 structured binding)</summary>
                    </header>
                    <article>
                        Tuples are collections composed of heterogeneous objects of pre-arranged dimensions.
                        A tuple can be considered a generalization of a struct's member variables.
                        <cppblock>
                            typedef std::tuple&lt;int, double, long&, const char*> test_tuple;
                            long lengthy = 12;
                            test_tuple proof (18, 6.5, lengthy, "Ciao!");

                            lengthy = std::get<0>(proof);  // Assign to 'lengthy' the value 18.
                            std::get<3>(proof) = " Beautiful!";  // Modify the tuple’s fourth element.
                        </cppblock>
                    </article>
                </section>

                <section>
                    <h2 data-category=stl>initializer lists</h2>
                    <article style="font-size: 70%">
                        C++11 extends initializer-lists, so they can be used for all classes (C++03 allow them only on structs and classes that conform to the POD definition.
                        C++11 binds the concept to a template, called #(code:std::initializer_list)#.
                        This allows constructors and other functions to take initializer-lists as parameters.
                        <cppblock>
                            struct SequenceClass
                            {
                                SequenceClass(std::initializer_list&lt;int> list);
                            };
                        </cppblock>
                        This allows #(type:SequenceClass)# to be constructed from a sequence of integers, such as
                        <cppblock>
                            SequenceClass some_var = {1, 4, 5, 6};
                        </cppblock>
                        This constructor is a special kind of constructor, called an initializer-list-constructor.
                        Classes with such a constructor are treated specially during uniform initialization.
                        If a class has an initializer list constructor, then it takes priority over other forms of construction, provided that the initializer list conforms to the sequence constructor's type.
                    </article>
                </section>

                <section>
                    <h2>misc</h2>
                    <article>
                        <p>
                            C++11 allows #(keyword:sizeof)# to work on members of classes without an explicit object.
                        </p>
                    </article>
                </section>
                <!--
                    ### Extended friend declarations
                    ### Local and unnamed types as template parameters
                    ### Inline namespaces
                    ### New character types
                    ### Unicode string literals
                    ### ref qualifier
                    ### dynamic initializaion and destruction with concurrency(magic statics)
                -->
            </section>
<!--
                   CCCCCCCCCCC                                 111            4444  
                 CCCCCCCCCCCCCC                              11111           44444  
                CCCCC       CCC                            1111111         4444444  
                CCCC                +++          +++      11  1111       4444 4444  
                CCCC                +++          +++          1111      4444  4444  
                CCCC            +++++++++++  +++++++++++      1111     4444444444444
                CCCC            +++++++++++  +++++++++++      1111     4444444444444
                CCCCC       CCC     +++          +++          1111            4444  
                 CCCCCCCCCCCCCC     +++          +++          1111            4444  
                   CCCCCCCCCCC                            111111111111        4444  
-->
            <section>
                <section>
                    <h1>C++ 14</h1>
                    <nav data-auto="feature='new language feature', stl='new standard library feature', misc='miscellaneous'"/>
                </section>
                
                <section>
                    <h2>Tweaked wording for contextual conversions</h2>
                </section>

                <section>
                    <h2 data-category="feature">Binary literals</h2>
                </section>

                <section>
                    <h2>#(keyword:decltype(auto))#, Return type deduction for normal functions</h2>
                </section>

                <section>
                    <h2 data-category="feature">Initialized/Generalized lambda captures (init-capture)</h2>
                </section>

                <section>
                    <h2 data-category="feature">Generic (polymorphic) lambda expressions</h2>
                </section>

                <section>
                    <h2 data-category="feature">Variable templates</h2>
                </section>

                <section>
                    <h2 data-category="feature">Extended constexpr</h2>
                </section>

                <section>
                    <h2>Member initializers and aggregates (NSDMI)</h2>
                </section>

                <section>
                    <h2>Clarifying memory allocation (avoiding/fusing allocations)</h2>
                </section>

                <section>
                    <h2 data-category="feature">[[deprecated]] attribute</h2>
                </section>

                <section>
                    <h2 data-category="feature">Sized deallocation</h2>
                </section>

                <section>
                    <h2 data-category="feature">Single quote as digit separator</h2>
                </section>

                <section>
                    <h2 data-category="stl">#(type:std::result_of)# and SFINAE</h2>
                </section>

                <section>
                    <h2 data-category="stl">#(keyword:constexpr)# for #(header:complex)#</h2>
                </section>

                <section>
                    <h2 data-category="stl">#(keyword:constexpr)# for #(header:chrono)#</h2>
                </section>

                <section>
                    <h2 data-category="stl">#(keyword:constexpr)# for #(header:array)#</h2>
                </section>

                <section>
                    <h2 data-category="stl">#(keyword:constexpr)# for #(header:initializer_list)#, #(header:utility)#, #(header:tuple)#</h2>
                </section>

                <section>
                    <h2 data-category="stl">Improved #(type:std::integral_constant)#</h2>
                </section>
                
                <section>
                    <h2 data-category="stl">User-defined literals for #(header:chrono)# and #(header:string)#</h2>
                </section>
                
                <section>
                    <h2>Null forward iterators</h2>
                </section>

                <section>
                    <h2 data-category="stl">#(type:std::quoted)#</h2>
                </section>

                <section>
                    <h2>Heterogeneous associative lookup</h2>
                </section>

                <section>
                    <h2 data-category="stl">#(type:std::integer_sequence)#</h2>
                </section>

                <section>
                    <h2 data-category="stl">#(type:std::shared_timed_mutex)#</h2>
                </section>

                <section>
                    <h2 data-category="stl">#(type:std::exchange)#</h2>
                </section>
                
                <section>
                    <h2>fixing #(keyword:constexpr)# member functions without #(keyword:const)#</h2>
                </section>

                <section>
                    <h2 data-category="stl">#(type:std::get&lt;T&gt;)#</h2>
                </section>

                <section>
                    <h2 data-category="stl">Dual-Range #(type:std::equal)#, #(type:std::is_permutation)#, #(type:std::mismatch)#</h2>
                </section>
            </section>
<!--
                   CCCCCCCCCCC                                 111     7777777777777
                 CCCCCCCCCCCCCC                              11111     7777777777777
                CCCCC       CCC                            1111111             77777
                CCCC                +++          +++      11  1111            7777
                CCCC                +++          +++          1111           7777
                CCCC            +++++++++++  +++++++++++      1111          7777
                CCCC            +++++++++++  +++++++++++      1111          7777
                CCCCC       CCC     +++          +++          1111         7777
                 CCCCCCCCCCCCCC     +++          +++          1111         7777
                   CCCCCCCCCCC                            111111111111     7777
-->
            <section>
                <section>
                    <h1>C++ 17</h1>
                    <nav style="font-size: 45%" data-auto="usability='core language usability', functionality='core language functionality', stl='standard library', misc='miscellaneous', preprocessor='preprocessor functionalities', deprecated='deprecated functionalities'"/>
                </section>

                <section>
                    <h2 data-category="usability">New auto rules for direct-list-initialization</h2>
                </section>

                <section>
                    <h2 data-category="usability">#(keyword:static_assert)# with no message</h2>
                </section>

                <section>
                    <h2 data-category="usability">#(keyword:typename)# in a template template parameter</h2>
                </section>

                <section>
                    <h2 data-category="usability">Nested namespace definition</h2>
                </section>

                <section>
                    <h2 data-category="usability">u8 character literals</h2>
                </section>

                <section>
                    <h2 data-category="usability">Allow constant evaluation for all non-type template arguments</h2>
                </section>

                <section>
                    <h2 data-category="functionality">Fold Expressions</h2>
                </section>

                <section>
                    <h2 data-category="deprecated">Removing some deprecated features</h2>
                    <article>
                    <p>
                        Removing trigraphs
                    </p>
                    <p>
                        Remove deprecated use of the #(keyword:register)# keyword
                    </p>
                    <p>
                        Remove deprecated operator++(bool)
                    </p>
                    <p>
                        Removing deprecated exception specifications
                    </p>
                    </article>
                </section>

                <section>
                    <h2 data-category="functionality">exception specifications part of the type</h2>
                    <article>
                        <p>
                            The exception specification of a function is now considered as a part of its type.
                        </p>
                        <p>
                            A prvalue of type "pointer to noexcept function" can be converted to a prvalue of type "pointer to function".
                            The result is a pointer to the function.
                        </p>
                        <p>
                            A prvalue of type "pointer to member of type noexcept function" can be converted to a prvalue of type "pointer to member of type function".
                            The result points to the member function.
                        </p>
                    </article>
                </section>

                <section>
                    <h2 data-category="functionality">Aggregate initialization of classes with base classes</h2>
                </section>

                <section>
                    <h2 data-category="usability">Lambda capture of *this</h2>
                </section>

                <section>
                    <h2 data-category="functionality">Dynamic memory allocation for over-aligned data</h2>
                </section>

                <section>
                    <h2 data-category="usability">Unary fold expressions & empty parameter packs</h2>
                </section>

                <section>
                    <h2 data-category="preprocessor">__has_include in preprocessor conditionals</h2>
                </section>

                <section>
                    <h2 data-category="usability">Template argument deduction for classes</h2>
                    <article>
                        Template argument deduction for class templates
                    </article>
                </section>

                <section>
                    <h2 data-category="usability">Non-type template parameters with auto type</h2>
                </section>

                <section>
                    <h2 data-category="functionality">Guaranteed copy elision</h2>
                </section>

                <section>
                    <h2 data-category="usability">New specification for inheriting constructors</h2>
                </section>

                <section>
                    <h2 data-category="usability">Direct-list-initialization of enumerations</h2>
                    <article>
                        The bug of C++17 specification...
                    </article>
                </section>

                <section>
                    <h2 data-category="usability">Stricter expression evaluation order</h2>
                </section>

                <section>
                    <h2 data-category="usability">constexpr lambda expressions</h2>
                </section>

                <section>
                    <h2 data-category="usability">Differing begin & end types in range-based for</h2>
                </section>

                <section>
                    <h2 data-category="functionality">#(attribute:fallthrough)#</h2>
                    <p>
                        <!-- [[fallthrough]] attribute -->
                        <article style="font-size:70%">
                            The attribute-token #(attribute:fallthrough)# may be applied to a null statement that precedes a case of default label statement within a switch statement.
                            <cppblock style="font-size:60%">
                                void f(int n) {
                                    void g(), h(), i();
                                    switch (n) {
                                    case 1:
                                    case 2: // OK
                                        g();
                                        [[fallthrough]];
                                    case 3: // OK
                                        h();
                                    case 4:
                                        i();
                                        [[fallthrough]]; // error: annotation does not directly precede switch label
                                        j();
                                    case 5: // warning: unannotated fall-through between switch labels
                                        k();
                                        [[fallthrough]]; // error: annotation does not directly precede switch label
                                    }
                                }
                            </cppblock>
                            To activate on clang:  <i>-Wimplicit-fallthrough</i>
                        </article>
                    </p>
                    <!-- <div style="position: absolute; top:0; left: 0; overflow:hidden; height:100%; width: 100%;">
                        <div style="background-color: rgba(0, 128, 0, 0.5); width: 300px; display: inline-block; transform: translate(-50%, -50%) rotate(-45deg); font-size: 50%; font-weight: bold; position: absolute; top: 60px; left: 60px;">
                            MANDATORY
                        </div>
                    </div> -->
                    <div class="ribbon green topleft"><div>MANDATORY</div></div>
                    <div class="ribbon yellow topright"><div>RECOMMENDED</div></div>
                    <!-- <div style="position: absolute; top:0; right: 0; overflow:hidden; height:100%; width: 100%;">
                        <div style="background-color: rgba(234, 238, 28, 0.5); width: 300px; display: inline-block; transform: translate(50%, -50%) rotate(45deg); font-size: 50%; font-weight: bold; position: absolute; top: 60px; right: 60px;">
                            RECOMMENDED
                        </div>
                    </div> -->
                </section>

                <section>
                    <h2 data-category="functionality">About [[attributes]]</h2>
                    <p>
                        [[nodiscard]] attribute
                    </p>
                    <p>
                        [[maybe_unused]] attribute
                    </p>
                    <p>
                        Ignore unknown attributes
                    </p>
                    <p>
                        Attributes for namespaces and enumerators
                    </p>
                    <p>
                        Using attribute namespaces without repetition
                    </p>
                </section>

                <section>
                    <h2 data-category="functionality">Structured Bindings</h2>
                </section>

                <section>
                    <h2 data-category="usability">Pack expansions in using-declarations</h2>
                </section>

                <section>
                    <h2 data-category="functionality">Hexadecimal floating-point literals</h2>
                </section>

                <section>
                    <h2 data-category="functionality">constexpr if statements</h2>
                </section>

                <section>
                    <h2 data-category="functionality">init-statements for if and switch</h2>
                </section>

                <section>
                    <h2 data-category="functionality">Inline variables</h2>
                </section>

                <section>
                    <h2 data-category="usability">DR: Matching of template template-arguments excludes compatible templates</h2>
                </section>

                <section>
                    <h2 data-category="stl"><span data-no-clang>Standardization of Parallelism TS</span></h2>
                    <article>
                        #(header:execution_policy)#
                    </article>
                </section>

                <section>
                    <h2 data-category="stl">std::uncaught_exceptions()</h2>
                </section>

                <section>
                    <h2 data-category="stl"><span data-no-clang>Splicing Maps and Sets</span></h2>
                </section>

                <section>
                    <h2 data-category="stl">Improving std::pair and std::tuple</h2>
                </section>

                <section>
                    <h2 data-category="stl">std::shared_mutex (untimed)</h2>
                </section>

                <section>
                    <h2 data-category="stl"><span data-no-clang>Elementary string conversions</span></h2>
                    <article>
                        #(header:charconv)#<br>
                        std::from_chars<br>
                        std::to_chars
                    </article>
                </section>

                <section>
                    <h2 data-category="stl">std::string_view</h2>
                </section>

                <section>
                    <h2 data-category="stl"><span data-no-clang>std::filesystem</span></h2>
                </section>
            </section>
        </div>
    </div>

    <script src="revealjs/lib/js/head.min.js"></script>
    <script src="revealjs/js/reveal.js"></script>
    <script src="mod/mod4revealjs.js"></script>
    <script>
        // More info about config & dependencies:
        // - https://github.com/hakimel/reveal.js#configuration
        // - https://github.com/hakimel/reveal.js#dependencies
        Reveal.initialize({
            dependencies: [
                { src: 'revealjs/plugin/markdown/marked.js' },
                { src: 'revealjs/plugin/markdown/markdown.js' },
                { src: 'revealjs/plugin/notes/notes.js', async: true },
                { src: 'revealjs/plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); initAfterHighlightJS(); } },
            ],
            width: 1280,
            height: 720,
            margin: -0.010,
            // margin: 0.025,
            history: true,
            mouseWheel: true,
            center: false,
            display: 'block',
        });
    </script>
</body>

</html>
