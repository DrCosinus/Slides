<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Shake // Modern C++ Features</title>

    <link rel="stylesheet" href="revealjs/css/reveal.css">
    <link rel="stylesheet" href="revealjs/css/theme/black.css">
    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="revealjs/lib/css/zenburn.css">
    <link rel="stylesheet" href="mod/mod4revealjs.css">
    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'revealjs/css/print/pdf.css' : 'revealjs/css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>

<body>
    <div class="reveal">
        <div class="slides">
            <section>
                <h2>Modern C++ Features</h2>
                <h3>Past / Present / Future</h3>
            </section>

            <section>
                <section id="cpp11">
                    <h1>C++ 11</h1>
                    <toc/>
                </section>

                <section>
                    <h2><cppkeyword>alignas</cppkeyword> and <cppkeyword>alignof</cppkeyword></h2>
                    <ribbon>
                        <cell><key>Current usage</key><value>not used a lot</value></cell>
                        <cell><key>Current directive</key><value>almost never recommended</value></cell>
                        <cell><key>Future directive</key><value>To use as soon as necessary</value></cell>
                    </ribbon>
                    <description>
                        C++11 allows variable alignment to be queried and controlled withs <cppkeyword>alignof</cppkeyword> and <cppkeyword>alignas</cppkeyword>.
                        The <cppkeyword>alignof</cppkeyword> operator takes the type and returns the power of 2 byte boundary on which the type instances must be allocated (as a <cpptype>std::size_t</cpptype>). When given a reference type alignof returns the referenced type's alignment; for arrays it returns the element type's alignment.
                        The <cppkeyword>alignas</cppkeyword> specifier controls the memory alignment for a variable. The specifier takes a constant or a type; when supplied a type <cppcode>alignas(T)</cppcode> is shorthand for <cppcode>alignas(alignof(T))</cppcode>. For example, to specify that a char array should be properly aligned to hold a float:
                        <cppblock>
                            alignas(float) unsigned char c[sizeof(float)];
                        </cppblock>
                    </description>
                </section>

                <section>
                    <h2>atomic operations</h2>
                    <ribbon>
                        <cell><key>Current usage</key><value>little used</value></cell>
                        <cell><key>Current directive</key><value>almost never recommended</value></cell>
                        <cell><key>Future directive</key><value>To use as soon as necessary</value></cell>
                    </ribbon>
                    <description>
                        Le C++11 introduit la bibliothèque des opérations atomiques nécéssaire à un programmation concurrentielle sans verrou. Chaque opération atomiques est insécable au regard de toute autre opération atomique impliquant le même objet. Les objets atomiques sont exempts de "data races". Les opérations atomiques sont définies dans le fichier d'entêtes <cppheader>atomic</cppheader>.
                    </description>
                    </small>
                </section>

                <section>
                    <h2><cppkeyword>auto</cppkeyword></h2>
                    <ribbon>
                        <cell><key>Current usage</key><value>very used</value></cell>
                        <cell><key>Current directive</key><value>recommended</value></cell>
                        <cell><key>Future directive</key><value>To use as soon as possible</value></cell>
                    </ribbon>
                    <description>
                        C++11 allows type inference.<br>
                        The definition of a variable with an explicit initialization can use the <cppkeyword>auto</cppkeyword> keyword.<br>
                        This creates a variable of the specific type of the initializer:<br>
                        <cppblock style="font-size: 95%">
                            auto some_strange_callable_type = std::bind(&amp;some_function, _2, _1, some_object);
                            auto other_variable = 5;
                        </cppblock>
                        <p style="font-size: 250%; margin-top: 0.8em;">Almost always <cppkeyword>auto</cppkeyword>?</p>
                    </description>
                    </small>
                </section>

                <section>
                    <h2><cppkeyword>constexpr</cppkeyword></h2>
                    <ribbon>
                        <cell><key>Current usage</key><value>Used</value></cell>
                        <cell><key>Current directive</key><value>sometimes recommended</value></cell>
                        <cell><key>Future directive</key><value>to use</value></cell>
                    </ribbon>
                    <description>
                        <p style="font-size: 80%">
                            C++11 introduced the keyword constexpr, which allows the user to guarantee that a function or object constructor is a compile-time constant.
                            So, a constant expression is allowed to contain a function call or object constructor (the compiler can verify that it is compile-time constant).
                        </p>
                        <p style="font-size: 80%">
                            In C++11, there are some limitations for constexpr functions and constructors (non-void return type, no variable declarations or new types in the function body, only one return statement).
                        </p>
                        <p style="font-size: 80%">
                            If it is called with not constant expression arguments, the call behaves as if the function were not constexpr, and the resulting value is not a constant expression.
                            Likewise, if the expression in the return statement of a constexpr function does not evaluate to a constant expression for a given invocation, the result is not a constant expression.
                        </p>
                        <cppblock style="font-size: 80%">
                            constexpr int siz() { return 42; }
                            int array[siz() + 17]; // illformed if siz() is not constexpr
                            template&lt;int I&gt; struct Bar {};
                            Bar&lt;siz()&gt; bar;  // illformed if siz() is not constexpr
                        </cppblock>
                    </description>
                </section>

                <section>
                    <h2><cppkeyword>decltype</cppkeyword></h2>
                    <ribbon>
                        <cell><key>Current usage</key><value>uncommon</value></cell>
                        <cell><key>Current directive</key><value>rarely needed (TMP)</value></cell>
                        <cell><key>Future directive</key><value>To use as soon as necessary (TMP)</value></cell>
                    </ribbon>
                    <description>
                        The keyword <cppkeyword>decltype</cppkeyword> can be used to determine the type of expression at compile-time.
                        <cppblock>
                            unsigned int some_int;
                            decltype(some_int) other_integer_variable = 5;
                        </cppblock>
                    </description>
                </section>

                <section>
                    <h2>Defaulted &amp; deleted functions</h2>
                    <ribbon>
                        <cell><key>Current usage</key><value>used</value></cell>
                        <cell><key>Current directive</key><value>often recommended</value></cell>
                        <cell><key>Future directive</key><value>To use whenever possible</value></cell>
                    </ribbon>
                    <description>
                        C++11 allows the explicit defaulting and deleting of special member functions.
                        <cppblock>
                            struct Foo
                            {
                                Foo() = default; // explicit instantiantion of default constructor
                                Foo(int _value);
                            };
                            struct NonCopyable
                            {
                                NonCopyable() = default;
                                NonCopyable(const NonCopiable&amp;) = delete;
                                NonCopyable&amp; operator=(const NonCopiable&amp;) = delete;
                            };
                        </cppblock>
                    </description>
                </section>

                <section>
                    <h2 no-toc>Defaulted &amp; deleted functions</h2>
                    <description>
                        The <cppcode>= delete</cppcode> specifier can be used to prohibit calling any function, which can be used to disallow calling a member function with particular parameters (and to guard against implicit cast).
                        <cppblock style="font-size: 90%;">
                            struct Foo
                            {
                              Foo(double) {}
                              Foo(int) = delete;                      // &lt;== guard from conversion from int
                            };
                            struct Bar
                            {
                              Bar(double) {}
                              template&lt;typename T&gt; Bar(T) = delete;  // &lt;== guard from any conversion but double
                            };
                        </cppblock>
                    </description>
                </section>

                <section>
                    <h2>Delegating constructors</h2>
                    <ribbon>
                        <cell><key>Current usage</key><value>not used a lot</value></cell>
                        <cell><key>Current directive</key><value>sometimes recommended</value></cell>
                        <cell><key>Future directive</key><value>To be used as soon as possible</value></cell>
                    </ribbon>
                    <description>
                        C++11 allows constructors to call other peer constructors.
                        <cppblock>
                            struct Foo
                            {
                                Foo(int _value) : value_(_value) {}
                                Foo() : Foo(42) {} // &lt;== this constructor calls the other one
                            private:
                                int value_;
                            };
                        </cppblock>
                    </description>
                </section>

                <section>
                    <h2>inheriting constructors</h2>
                    <ribbon>
                        <cell><key>Current usage</key><value>Not used a lot</value></cell>
                        <cell><key>Current directive</key><value>Sometimes recommended</value></cell>
                        <cell><key>Future directive</key><value>To be used as soon as possible</value></cell>
                    </ribbon>
                    <description>
                        C++11 allows a class to specify that base class constructors will be inherited.
                        <cppblock style="font-size: 80%">
                            struct Parent
                            {
                                explicit Parent(int _value) : value_{_value} {}
                                Parent() : value_(-1) {}
                                Parent(int _value1, int _value2) : value_{_value1 + _value2} {}
                            private:
                                int value_;
                            };
                            struct Child : Parent
                            {
                                using Parent::Parent; // &lt;== inheriting all constructors of Parent
                            };
                            ...
                            Child child0, child1{14, 28}, child2{17}; // child values are respectively: -1 42 17
                        </cppblock>
                    </description>
                </section>

                <section>
                    <h2><cppkeyword>nullptr</cppkeyword></h2>
                    <ribbon>
                        <cell><key>Current usage</key><value>very used</value></cell>
                        <cell><key>Current directive</key><value>mandatory</value></cell>
                        <cell><key>Future directive</key><value>mandatory</value></cell>
                    </ribbon>
                    <description>
                        C++11 introduces a new keyword to serve as a distinguished null pointer constant: <cppkeyword>nullptr</cppkeyword>>.
                        It is of type <cpptype>std::nullptr_t</cpptype>, which is implicitly convertible and comparable to any pointer type or pointer-to-member type.
                        It is not implicitly convertible or comparable to integral types, except for <cpptype>bool</cpptype>.
                    </description>
                </section>

                <section>
                    <h2><cppkeyword>static_assert</cppkeyword></h2>
                    <ribbon>
                        <cell><key>Current usage</key><value>used</value></cell>
                        <cell><key>Current directive</key><value>recommended</value></cell>
                        <cell><key>Future directive</key><value>recommended</value></cell>
                    </ribbon>
                    <description>
                        C++11 introduces a new way to test assertions at compile-time, using the new keyword <cppkeyword>static_assert</cppkeyword>.
                        <cppblock style="font-size: 80%">
                            static_assert((MC_PI > 3.14) && (MC_PI < 3.15), "MC_PI is inaccurate!");

                            template&lt;typename T>
                            struct Check
                            {
                              static_assert(sizeof(int) <= sizeof(T), "T is not big enough!");
                            };

                            template&lt;typename INTEGRAL>
                            INTEGRAL foo(INTEGRAL x, INTEGRAL y)
                            {
                              static_assert(std::is_integral&lt;INTEGRAL>::value,
                                "foo() parameter must be an integral type.");
                            }
                        </cppblock>
                    </description>
                </section>

                <section>
                    <h2>Strongly-typed enumerations</h2>
                    <ribbon>
                        <cell><key>Current usage</key><value>used if not to be serializable</value></cell>
                        <cell><key>Current directive</key><value>recommended</value></cell>
                        <cell><key>Future directive</key><value>recommended</value></cell>
                    </ribbon>
                    <description style="text-align: left; font-size: 60%;">
                        <p>
                            C++11 provides strongly-typed enumerations:
                            <ul>
                                <li>it can not be used for/assigned to/compared with another enumeration.</li>
                                <li>it is not implicitly converted to <cpptype>int</cpptype>.</li>
                                <li>there is no risk of name collisions due to the need to use scope resolution operator to access values,</li>
                                <li>the underlying type can be overridden to a different integral type (<cpptype>int</cpptype> by default)</li>
                            </ul>
                        </p>
                        <p>
                            Forward-declaring enums is possible in C+11. As long as the size of the enumeration is specified either implicitly or explicitly, it can be forward-declared:
                            <cppblock style=" font-size: 70%;">
                                enum Enum1;                      // Invalid in C++03 and C++11; the underlying type cannot be determined.
                                enum Enum2 : unsigned int;       // Valid in C++11, the underlying type is specified explicitly.
                                enum class Enum3;                // Valid in C++11, the underlying type is int.
                                enum class Enum4 : unsigned int; // Valid in C++11.
                                enum Enum2 : unsigned short;     // Invalid in C++11, because Enum2 was formerly declared with a different underlying type.
                            </cppblock>
                        </p>
                        <p>
                            C++11 allows the forward-declaration, the use of the scope resolution operator, and the choice of the underlying type <strong>even for old-style enumerations</strong>.
                        </p>
                    </description>
                </section>

                <section>
                    <h2>Template aliases</h2>
                    <ribbon>
                        <cell><key>Current usage</key><value>used => <cppkeyword>typedef</cppkeyword> is deprecated</value></cell>
                        <cell><key>Current directive</key><value>recommended</value></cell>
                        <cell><key>Future directive</key><value>recommended</value></cell>
                    </ribbon>
                    <description>
                        C++11 allows to create templated synonym for template type.
                        The template parameters of the synonym can be different of the template parameters of the original type.<br>
                        <cppblock style="font-size: 90%">
                            template&lt;typename First, typename Second, int Third>
                            class SomeType;

                            template&lt;typename Second>
                            using TypedefName = SomeType&lt;OtherType, Second, 5>;
                        </cppblock>
                        The syntax is generalized to define any synonym type in a more intuitively readable manner.
                        <cppblock style="font-size: 90%">
                            typedef void (*OldFunctionType)(double);  // <== old style. tricky to read 

                            using NewFunctionType = void (*)(double); // <== new style. more obvious
                        </cppblock>
                    </description>
                </section>

                <section>
                    <h2>variadic templates</h2>
                    <ribbon>
                        <cell><key>Current usage</key><value>very little used</value></cell>
                        <cell><key>Current directive</key><value>never recommended</value></cell>
                        <cell><key>Future directive</key><value>recommended for specific use</value></cell>
                    </ribbon>
                    <description>
                        In C++11, templates can take variable numbers of template parameters.<br>
                        This also allows the definition of type-safe variadic functions
                    </description>
                </section>

                <section>
                    <h2>extern templates</h2>
                    <ribbon>
                        <cell><key>Current usage</key><value>very little used</value></cell>
                        <cell><key>Current directive</key><value>very little recommended</value></cell>
                        <cell><key>Future directive</key><value>recommended if needed</value></cell>
                    </ribbon>
                    <description>
                        C++11 provdied a syntax to tell the compiler <span style="text-decoration: underline; font-weight: bolder">not</span> to instantiate the template in this translation unit.
                    </description>
                </section>
    
                <section>
                    <h2>Thread-local storage</h2>
                    <ribbon>
                        <cell><key>Current usage</key><value>...</value></cell>
                        <cell><key>Current directive</key><value>...</value></cell>
                        <cell><key>Future directive</key><value>...</value></cell>
                    </ribbon>
                    <description>
                        C++11 introduces the keyword <cppkeyword>thread_local</cppkeyword>.<br>
                        Any object which could have static storage duration may be given thread-local duration instead.<br>
                        Each thread holds its own copy of such variables.<br>
                        Lifetime of each copies of these variables is bound to the thread holding them.
                    </description>
                </section>

                <section>
                    <h2>unrestricted unions</h2>
                    <ribbon>
                        <cell><key>Current usage</key><value>...</value></cell>
                        <cell><key>Current directive</key><value>...</value></cell>
                        <cell><key>Future directive</key><value>...</value></cell>
                    </ribbon>
                    <description>
                        C++11 lifts some restrictions on what types can me members of a <cppkeyword>union</cppkeyword>.
                        Unions can now have member with non trivial special member functions but it must be <u>manually defined</u>.
                        <cppblock style="font-size:65%;">
                            #include &lt;new> // Needed for placement 'new'.
                            struct Point {
                                Point() {}
                                Point(int _x, int _y): x_(_x), y_(_y) {}
                                int x_, y_;
                            };
                            union U {
                                int z;
                                double w;
                                Point p;
                                U() {} // Due to the Point member, a constructor definition is needed.
                                U(const Point& pt) : p(pt) {} // Construct Point object using initializer list.
                                U& operator=(const Point& pt) { new(&p) Point(pt); return *this; } // Assign Point object using placement 'new'.
                            };
                        </cppblock>
                    </description>
                </section>

                <section>
                    <h2>non-static data member initializers</h2>
                    <ribbon>
                        <cell><key>Current usage</key><value>rarely used</value></cell>
                        <cell><key>Current directive</key><value>sometimes recommended</value></cell>
                        <cell><key>Future directive</key><value>recommended</value></cell>
                    </ribbon>
                    <description>
                        C++11 allow to assign a default value to non-static data members.
                        Each constructor will initialize these members with the default value only if it does not override the initialization with its own.
                    </description>
                    <cppblock style="font-size:60%">
                        struct Foo
                        {
                            Foo() {}             // value_ initialized with 509
                            explicit Foo(int _value)
                             : value_(_value) {} // value_ initialized with given parameter
                        private:
                            int value_ = 509;
                        };
                    </cppblock>
                </section>

                <section>
                    <h2>Range-for loop</h2>
                    <ribbon>
                        <cell><key>Current usage</key><value>very use</value></cell>
                        <cell><key>Current directive</key><value>recommended</value></cell>
                        <cell><key>Future directive</key><value>recommended</value></cell>
                    </ribbon>
                    <description>
                        C++11 extends the syntax of the <cppkeyword>for</cppkeyword> statement to allow for easy iteration over a range of elements.
                        <cppblock>
                            int my_array[5] = {1, 2, 3, 4, 5};
                            // double the value of each element in my_array:
                            for (int& x : my_array)
                            {
                                x *= 2;
                            }
                        </cppblock>
                    </description>
                </section>

                <section>
                    <h2>lambda expressions</h2>
                    <ribbon>
                        <cell><key>Current usage</key><value>very use</value></cell>
                        <cell><key>Current directive</key><value>recommended</value></cell>
                        <cell><key>Future directive</key><value>recommended</value></cell>
                    </ribbon>
                    <description>
                        <p>
                            C++11 provides the ability to create anonymous functions, called lambda functions.
                        </p>
                        <p>
                            These are defined as follows: <cppcode>[](int x, int y) -> int { return x + y; }</cppcode>
                        </p>
                        <p>T
                            he return type can be omitted when all <cppkeyword>return</cppkeyword> returns the same type: <cppcode>[](int x, int y) { return x + y; }</cppcode>
                        </p>
                        <p>
                            The type of a lambda is unspecified. User must use <cppkeyword>auto</cppkeyword>:
                            <cppcode>auto lambda = [](int x, int y) { return x + y; }</cppcode>
                        </p>
                        <p>
                            A lambda can capture variables (by copy or by reference):
                            <cppcode>[copy, &amp;ref](int x) { ref = x + copy; }</cppcode>
                        </p>
                        <p>
                            A lamba which capture no variable can be converted into a function pointer:
                            <cppblock>
                                int f(int(*_callback)(int, int)) { return _callback( 17, 25 ); }
                                int r = f([](int x, int y){ return x + y; });
                            </cppblock>
                        </p>
                    </description>
                </section>

                <section>
                    <h2>override and final</h2>
                    <ribbon>
                        <cell><key>Current usage</key><value>compilation error if <cppkeyword>override</cppkeyword> is missing</value> </cell>
                        <cell><key>Current directive</key><value><cppkeyword>override</cppkeyword> is mandatory</value></cell>
                        <cell><key>Future directive</key><value><cppkeyword>override</cppkeyword> is mandatory</value></cell>
                    </ribbon>
                    <description>
                        <p>
                            C++11 provides syntax to prevent from bad virtual function overriding.
                        </p>
                        <p>
                            The <cppkeyword>override</cppkeyword> special identifier means that the compiler will check the base classes to see if there is a vistual function with this exact signature.
                            If there is not, the compiler will indicate an error.
                        </p>
                        <cppblock style="font-size: 80%">
                            struct Base
                            { virtual void foo(float);
                            };
                            struct Derived : Base
                            { void foo(int) override; // error: doesn't override a base class method
                            };
                        </cppblock>
                        <p>
                            C+11 also adds the ability to prevent inheriting from classes or simply preventing overriding method in derived classes.
                            This is done with special identifier <cppkeyword>final</cppkeyword>.
                        </p>
                    </description>
                </section>

                <section>
                    <h2>rvalue reference and move semantics</h2>
                    <ribbon>
                        <cell><key>Current usage</key><value>use</value></cell>
                        <cell><key>Current directive</key><value>recommended if needed</value></cell>
                        <cell><key>Future directive</key><value>recommended if needed</value></cell>
                    </ribbon>
                    <description>
                        <p>
                            C++11 adds a new non-const reference type called an rvalue reference, identified by <cppcode>T&&</cppcode>.
                            This refers to temporaries that are permitted to be modified after they are initialized, for the purpose of allowing "move semantics".
                        </p>
                        <p>
                            For safety reasons, some restrictions are imposed. A named variable will never be considered to be an rvalue even if it is declared as such.
                            To get an rvalue, the function template <cppcode>std::move()</cppcode> should be used.
                        </p>
                    </description>
                </section>

                <section>
                    <h2>Raw string literals</h2>
                    <ribbon>
                        <cell><key>Current usage</key><value>never used</value></cell>
                        <cell><key>Current directive</key><value>never think about them</value></cell>
                        <cell><key>Future directive</key><value>to be considered if needed</value></cell>
                    </ribbon>
                    <description>
                        C++11 provides a raw string literal:
                        <p style="background-color: rgba(0,0,0,0.3); margin: 0 13%;">
                            <cppblock>
                                R"(The String Data \ Stuff " )"
                            </cppblock>
                            In this first case, everything between the <cppcode>"(</cppcode> and the <cppcode>)"</cppcode> is part of the string.<br>
                            The <cppcode>"</cppcode> and <cppcode>\</cppcode> characters do not need to be escaped.
                        </p>
                        <p style="background-color: rgba(0,0,0,0.3);">
                            <cppblock>
                                R"delimiter(The String Data \ Stuff " )delimiter"
                            </cppblock>
                            In this second case, the <cppcode>"delimiter(</cppcode> starts the string, and it ends only when <cppcode>)delimiter"</cppcode> is reached.
                            The string <cppcode>delimiter</cppcode> can be any string up to 16 characters in length, including the empty string.
                            This string cannot contain spaces, control characters, <cppcode>(</cppcode>, <cppcode>)</cppcode>, or the <cppcode>\</cppcode> character.
                            Using this delimiter string allows the user to have <cppcode>)</cppcode> characters within raw string literals.
                        </p>
                    </description>
                </section>

                <section>
                    <h2>User-defined literals</h2>
                    <ribbon>
                        <cell><key>Current usage</key><value>very little used</value></cell>
                        <cell><key>Current directive</key><value>rarely recommended</value></cell>
                        <cell><key>Future directive</key><value>to be considered if needed</value></cell>
                    </ribbon>
                    <description>
                        <p>
                            C++11 enables the user to define new kinds of literal modifiers that will construct objects based on the string of characters that the literal modifies.
                            Transformation of literals is redefined into two distinct phases: raw and cooked.
                            A raw literal is a sequence of characters of some specific type, while the cooked literal is of a separate type.
                            The C++ literal <cppcode>1234</cppcode>, as a raw literal, is this sequence of characters <cppcode>'1'</cppcode>, <cppcode>'2'</cppcode>, <cppcode>'3'</cppcode>, <cppcode>'4'</cppcode>.
                            As a cooked literal, it is the integer 1234.
                            The C++ literal <cppcode>0xA</cppcode> in raw form is <cppcode>'0'</cppcode>, <cppcode>'x'</cppcode>, <cppcode>'A'</cppcode>, while in cooked form it is the integer 10.
                        </p>
                        <p>
                            All user-defined literals are suffixes; defining prefix literals is not possible.
                            All suffixes starting with any character except underscore (<cppcode>_</cppcode>) are reserved by the standard.
                            Thus, all user-defined literals must have suffixes starting with an underscore (<cppcode>_</cppcode>).
                        </p>
                    </description>
                </section>

                <section>
                    <h2>Explicit conversion operators</h2>
                    <ribbon>
                        <cell><key>Current usage</key><value>used</value></cell>
                        <cell><key>Current directive</key><value>recommended</value></cell>
                        <cell><key>Future directive</key><value>recommended</value></cell>
                    </ribbon>
                    <description>
                        In C++11, the <cppkeyword>explicit</cppkeyword> keyword can now be applied to conversion operators.
                        As with constructors, it prevents using those conversion functions in implicit conversions.
                        However, language contexts that specifically need a boolean value (the conditions of if-statements and loops, and operands to the logical operators) count as explicit conversions and can thus use a <cpptype>bool</cpptype> conversion operator.
                    </description>
                </section>

                <section>
                    <h2>noexcept</h2>
                    <ribbon>
                        <cell><key>Current usage</key><value>almost not used</value></cell>
                        <cell><key>Current directive</key><value>no recommendation</value></cell>
                        <cell><key>Future directive</key><value>???</value></cell>
                    </ribbon>
                    <description>
                        Compile-time specification of non-exception-throwing functions is available with the <cppkeyword>noexcept</cppkeyword> keyword, which is useful for optimization.
                    </description>
                </section>

                <section>
                    <h2>Trailing function return types</h2>
                    <ribbon>
                        <cell><key>Current usage</key><value>almost always used</value></cell>
                        <cell><key>Current directive</key><value>recommended</value></cell>
                        <cell><key>Future directive</key><value style="color: red;">abandoned</value></cell>
                    </ribbon>
                    <description>
                        C++11 introduced trailing-return-type function declaration syntax so the return type can depend on function parameters:
                        <cppblock style="font-size: 80%">
                            template&lt;typename Lhs, typename Rhs>
                            auto adding_func(const Lhs &lhs, const Rhs &rhs) -> decltype(lhs+rhs) {return lhs + rhs;}
                        </cppblock>
                        This syntax can be used for classic function declarations and definitions.
                        <cppblock style="font-size: 80%">
                            struct SomeStruct
                            {
                                auto func_name(int x, int y) -> int;
                            };
                            auto SomeStruct::func_name(int x, int y) -> int
                            {
                                return x + y;
                            }
                        </cppblock>
                    </description>
                </section>

                <section>
                    <h2>Type <cpptype>long long int</cpptype></h2>
                    <ribbon>
                        <cell><key>Current usage</key><value>almost not used</value></cell>
                        <cell><key>Current directive</key><value>no recommendation</value></cell>
                        <cell><key>Future directive</key><value>???</value></cell>
                    </ribbon>
                    <description>
                        C++11 adds a new integer type <cpptype>long long int</cpptype> to address the problem that type <cpptype>long int</cpptype> having size of 64 bits on some popular implementations and 32 bits on others.
                        The new type is guaranteed to be at least as large as a long int, and have no fewer than 64 bits.
                    </description>
                </section>

                <section>
                    <h2>Uniform initialization</h2>
                    <ribbon>
                        <cell><key>Current usage</key><value>used</value></cell>
                        <cell><key>Current directive</key><value>sometimes recommended</value></cell>
                        <cell><key>Future directive</key><value>recommended</value></cell>
                    </ribbon>
                    <description style="font-size: 50%">
                        C++11 provides a syntax that allows for fully uniform type initialization that works on any object.
                        It expands on the initializer list syntax:
                        <div style="column-count: 2; font-size: 90%;">
                            <cppblock>
                                struct BasicStruct
                                {
                                    int x;
                                    double y;
                                };
                                struct AltStruct
                                {
                                    AltStruct(int x, double y) : x_{x}, y_{y}
                                    {}
                                private:
                                    int x_;
                                    double y_;
                                };
                                BasicStruct var1{5, 3.2};
                                AltStruct var2{2, 4.3};
                            </cppblock><br>
                            <cppblock>
                                struct IdString
                                {
                                    std::string name;
                                    int identifier;
                                };
                                
                                IdString get_string()
                                {
                                    return {"foo", 42}; //Note the lack of explicit type.
                                }
                            </cppblock>
                        </div>

                    </description>
                </section>


                <section>
                    <h2>Variadic macros</h2>
                    <ribbon>
                        <cell><key>Current usage</key><value>Used in very specific cases</value></cell>
                        <cell><key>Current directive</key><value>Very rarely needed</value></cell>
                        <cell><key>Future directive</key><value>only when you have no choice</value></cell>
                    </ribbon>
                    <description>
                        <cppblock>
                            #define FOO(...) fprintf(stderr, __VA_ARGS__)
                            #define BAR(...) puts(#__VA_ARGS__)
                            #define QUZ(check, ...) ((check)?puts(#check):printf(__VA_ARGS__))
                            FOO("a = %d\n", a);
                            BAR(First, second and third);
                            QUZ(x>z, "x is %d and y is %d", x, y);
                        </cppblock>
                        becomes after the preprocessor pass
                        <cppblock>
                            fprintf(stderr, "a = %d\n", a);
                            puts("First, second and third");
                            ((x>z)?puts("x>z"):printf("x is %d and y is %d", x, y))
                        </cppblock>
                    </description>
                </section>

                <section>
                    <h2>Right angle bracket</h2>
                    <description>
                        C++11 improves the specification of the parser so that multiple right angle brackets will be interpreted as closing the template argument list where it is reasonable.
                        This can be overridden by using parentheses around parameter expressions using the <q>></q>, <q>>=</q> or <q>>></q> binary operators:
                        <cppblock>
                            template&lt;bool Test> class SomeType;
                            std::vector&lt;SomeType&lt;1>2>> x1;  // Interpreted as a std::vector of SomeType&lt;true>,
                                // followed by "2 >> x1", which is not valid syntax for a declarator. 1 is true.
                            std::vector&lt;SomeType&lt;(1>2)>> x1;  // Interpreted as std::vector of SomeType&lt;false>,
                                // followed by the declarator "x1", which is valid C++11 syntax. (1>2) is false.
                        </cppblock>
                    </description>
                </section>

                <section>
                    <h2>STL</h2>
                    <description>
                        <ul>
                            <li>hashtables (<cpptype>std::unordered_set</cpptype>, <cpptype>std::unordered_map</cpptype>, ...)</li>
                            <li>Type traits for meta-programming (<cpptype>std::enable_if</cpptype>, <cpptype>std::conditional</cpptype>, ...)</li>
                            <li><cppcode>std::begin</cppcode>, <cppcode>std::end</cppcode></li>
                            <li><cpptype>std::reference_wrapper</cpptype></li>
                            <li>Extensible random number facility</li>
                            <li>Threading facilities</li>
                            <li>Polymorphic wrappers for function objects: <cpptype>std::function</cpptype></li>
                        </ul>
                    </description>
                </section>

                <section>
                    <h2>smart pointers</h2>
                    <ribbon>
                        <cell><key>Current usage</key><value>use</value></cell>
                        <cell><key>Current directive</key><value><cpptype>unique_ptr</cpptype> recommended</value></cell>
                        <cell><key>Future directive</key><value>recommended</value></cell>
                    </ribbon>
                    <description>
                        C++11 provides <cpptype>std::shared_ptr</cpptype>, <cpptype>std::weak_ptr</cpptype>, <cpptype>std::unique_ptr</cpptype>
                        <p><cpptype>std::auto_ptr</cpptype> is deprecated.</p>
                    </description>
                </section>
    
                <section>
                    <h2>Regular expressions</h2>
                    <ribbon>
                        <cell><key>Current usage</key><value>never used</value></cell>
                        <cell><key>Current directive</key><value>never think about them</value></cell>
                        <cell><key>Future directive</key><value>to be considered if needed</value></cell>
                    </ribbon>
                    <description>
                        The new library, defined in the new header <cppheader>regex</cppheader>, is made of a couple of new classes:
                        <ul>
                            <li>regular expressions are represented by instance of the template class <cpptype>std::regex</cpptype>,</li>
                            <li>occurences are represented by instance of the template class <cpptype>std::match_results</cpptype>.</li>
                        </ul>
                        <p>
                            The function <cppcode>std::regex_search</cppcode> is used for searching, and <cppcode>std::regex_replace</cppcode> is used for replacing.
                        </p>
                    </description>
                </section>

                <section>
                    <h2><cpptype>std::tuple</cpptype></h2>
                    <ribbon>
                        <cell><key>Current usage</key><value>quite never used</value></cell>
                        <cell><key>Current directive</key><value>never recommended</value></cell>
                        <cell><key>Future directive</key><value>recommended (see c++17 structured binding)</value></cell>
                    </ribbon>
                    <description>
                        Tuples are collections composed of heterogeneous objects of pre-arranged dimensions.
                        A tuple can be considered a generalization of a struct's member variables.
                        <cppblock>
                            typedef std::tuple&lt;int, double, long&, const char*> test_tuple;
                            long lengthy = 12;
                            test_tuple proof (18, 6.5, lengthy, "Ciao!");

                            lengthy = std::get<0>(proof);  // Assign to 'lengthy' the value 18.
                            std::get<3>(proof) = " Beautiful!";  // Modify the tuple’s fourth element.
                        </cppblock>
                    </description>
                </section>

                <section>
                    <h2>initializer lists</h2>
                    <description style="font-size: 70%">
                        C++11 extends initializer-lists, so they can be used for all classes (C++03 allow them only on structs and classes that conform to the POD definition.
                        C++11 binds the concept to a template, called <cppcode>std::initializer_list</cppcode>.
                        This allows constructors and other functions to take initializer-lists as parameters.
                        <cppblock>
                            struct SequenceClass
                            {
                                SequenceClass(std::initializer_list&lt;int> list);
                            };
                        </cppblock>
                        This allows <cpptype>SequenceClass</cpptype> to be constructed from a sequence of integers, such as
                        <cppblock>
                            SequenceClass some_var = {1, 4, 5, 6};
                        </cppblock>
                        This constructor is a special kind of constructor, called an initializer-list-constructor.
                        Classes with such a constructor are treated specially during uniform initialization.
                        If a class has an initializer list constructor, then it takes priority over other forms of construction, provided that the initializer list conforms to the sequence constructor's type.
                    </description>
                </section>

                <section>
                    <h2>misc</h2>
                    <description>
                        <p>
                            C++11 allows <cppkeyword>sizeof</cppkeyword> to work on members of classes without an explicit object.
                        </p>
                    </description>
                </section>
                <!--
                    ### Extended friend declarations
                    ### Local and unnamed types as template parameters
                    ### Inline namespaces
                    ### New character types
                    ### Unicode string literals
                    ### ref qualifier
                    ### dynamic initializaion and destruction with concurrency(magic statics)
                -->
            </section>
            
            <section>
                <section>
                    <h1>C++ 14</h1>
                    <toc/>
                </section>
                
                <section>
                    <h2>Tweaked wording for contextual conversions</h2>
                </section>

                <section>
                    <h2>Binary literals</h2>
                </section>

                <section>
                    <h2><cppkeyword>decltype(auto)</cppkeyword>, Return type deduction for normal functions</h2>
                </section>

                <section>
                    <h2>Initialized/Generalized lambda captures (init-capture)</h2>
                </section>

                <section>
                    <h2>Generic (polymorphic) lambda expressions</h2>
                </section>

                <section>
                    <h2>Variable templates</h2>
                </section>

                <section>
                    <h2>Extended constexpr</h2>
                </section>

                <section>
                    <h2>Member initializers and aggregates (NSDMI)</h2>
                </section>

                <section>
                    <h2>Clarifying memory allocation (avoiding/fusing allocations)</h2>
                </section>

                <section>
                    <h2>Deprecated attribute</h2>
                </section>

                <section>
                    <h2>Sized deallocation</h2>
                </section>

                <section>
                    <h2>Single quote as digit separator</h2>
                </section>

                <section>
                    <h2><cpptype>std::result_of</cpptype> and SFINAE</h2>
                </section>

                <section>
                    <h2><cppkeyword>constexpr</cppkeyword> for <cppheader>complex</cppheader></h2>
                </section>

                <section>
                    <h2><cppkeyword>constexpr</cppkeyword> for <cppheader>chrono</cppheader></h2>
                </section>

                <section>
                    <h2><cppkeyword>constexpr</cppkeyword> for <cppheader>array</cppheader></h2>
                </section>

                <section>
                    <h2><cppkeyword>constexpr</cppkeyword> for <cppheader>initializer_list</cppheader>, <cppheader>utility</cppheader>, <cppheader>tuple</cppheader></h2>
                </section>

                <section>
                    <h2>Improved <cpptype>std::integral_constant</cpptype></h2>
                </section>
                
                <section>
                    <h2>User-defined literals for <cppheader>chrono</cppheader> and <cppheader>string</cppheader></h2>
                </section>
                
                <section>
                    <h2>Null forward iterators</h2>
                </section>

                <section>
                    <h2><cpptype>std::quoted</cpptype></h2>
                </section>

                <section>
                    <h2>Heterogeneous associative lookup</h2>
                </section>

                <section>
                    <h2><cpptype>std::integer_sequence</cpptype></h2>
                </section>

                <section>
                    <h2><cpptype>std::shared_timed_mutex</cpptype></h2>
                </section>

                <section>
                    <h2><cpptype>std::exchange</cpptype></h2>
                </section>
                
                <section>
                    <h2>fixing <cppkeyword>constexpr</cppkeyword> member functions without <cppkeyword>const</cppkeyword></h2>
                </section>

                <section>
                    <h2><cpptype>std::get&lt;T&gt;</cpptype></h2>
                </section>

                <section>
                    <h2>Dual-Range <cpptype>std::equal</cpptype>, <cpptype>std::is_permutation</cpptype>, <cpptype>std::mismatch</cpptype></h2>
                </section>

            </section>

            <section>
                <section>
                    <h1>C++ 17</h1>
                    <toc class="for_priority"/>
                </section>

                <section>
                    <h2>New auto rules for direct-list-initialization</h2>
                </section>

                <section>
                    <h2><cppkeyword>static_assert</cppkeyword> with no message</h2>
                </section>

                <section>
                    <h2><cppkeyword>typename</cppkeyword> in a template template parameter</h2>
                </section>

                <section>
                    <h2>Removing trigraphs</h2>
                </section>

                <section>
                    <h2>Nested namespace definition</h2>
                </section>

                <section>
                    <h2>Attributes for namespaces and enumerators</h2>
                </section>

                <section>
                    <h2>u8 character literals</h2>
                </section>

                <section>
                    <h2>Allow constant evaluation for all non-type template arguments</h2>
                </section>

                <section>
                    <h2>Fold Expressions</h2>
                </section>

                <section>
                    <h2>Remove Deprecated Use of the register Keyword</h2>
                </section>

                <section>
                    <h2>Remove Deprecated operator++(bool)</h2>
                </section>

                <section>
                    <h2>Removing Deprecated Exception Specifications from C++17</h2>
                </section>

                <section>
                    <h2>Make exception specifications part of the type system</h2>
                </section>

                <section>
                    <h2>Aggregate initialization of classes with base classes</h2>
                </section>

                <section>
                    <h2>Lambda capture of *this</h2>
                </section>

                <section>
                    <h2>Using attribute namespaces without repetition</h2>
                </section>

                <section>
                    <h2>Dynamic memory allocation for over-aligned data</h2>
                </section>

                <section>
                    <h2>Unary fold expressions and empty parameter packs</h2>
                </section>

                <section>
                    <h2>__has_include in preprocessor conditionals</h2>
                </section>

                <section>
                    <h2>Template argument deduction for class templates</h2>
                </section>

                <section>
                    <h2>Non-type template parameters with auto type</h2>
                </section>

                <section>
                    <h2>Guaranteed copy elision</h2>
                </section>

                <section>
                    <h2>New specification for inheriting constructors</h2>
                </section>

                <section>
                    <h2>Direct-list-initialization of enumerations</h2>
                </section>

                <section>
                    <h2>Stricter expression evaluation order</h2>
                </section>

                <section>
                    <h2>constexpr lambda expressions</h2>
                </section>

                <section>
                    <h2>Differing begin and end types in range-based for</h2>
                </section>

                <section>
                    <h2>[[fallthrough]] attribute</h2>
                </section>

                <section>
                    <h2>[[nodiscard]] attribute</h2>
                </section>

                <section>
                    <h2>Pack expansions in using-declarations</h2>
                </section>

                <section>
                    <h2>[[maybe_unused]] attribute</h2>
                </section>

                <section>
                    <h2>Structured Bindings</h2>
                </section>

                <section>
                    <h2>Hexadecimal floating-point literals</h2>
                </section>

                <section>
                    <h2>Ignore unknown attributes</h2>
                </section>

                <section>
                    <h2>constexpr if statements</h2>
                </section>

                <section>
                    <h2>init-statements for if and switch</h2>
                </section>

                <section>
                    <h2>Inline variables</h2>
                </section>

                <section>
                    <h2>DR: Matching of template template-arguments excludes compatible templates</h2>
                </section>

                <section>
                    <h2>/*No*/ Standardization of Parallelism TS</h2>
                </section>

                <section>
                    <h2>std::uncaught_exceptions()</h2>
                </section>

                <section>
                    <h2>/*No*/ Splicing Maps and Sets</h2>
                </section>

                <section>
                    <h2>Improving std::pair and std::tuple</h2>
                </section>

                <section>
                    <h2>std::shared_mutex (untimed)</h2>
                </section>

                <section>
                    <h2>/*No*/ Elementary string conversions</h2>
                </section>

                <section>
                    <h2>std::string_view</h2>
                </section>

                <section>
                    <h2>/*No*/ std::filesystem</h2>
                </section>
            </section>
        </div>
    </div>

    <script src="revealjs/lib/js/head.min.js"></script>
    <script src="revealjs/js/reveal.js"></script>
    <script src="mod/mod4revealjs.js"></script>
    <script>
        // More info about config & dependencies:
        // - https://github.com/hakimel/reveal.js#configuration
        // - https://github.com/hakimel/reveal.js#dependencies
        Reveal.initialize({
            dependencies: [
                { src: 'revealjs/plugin/markdown/marked.js' },
                { src: 'revealjs/plugin/markdown/markdown.js' },
                { src: 'revealjs/plugin/notes/notes.js', async: true },
                { src: 'revealjs/plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); initAfterHighlightJS(); } },
            ],
            width: 1280,
            height: 720,
            margin: 0.025,
            history: true,
        });
    </script>
</body>

</html>